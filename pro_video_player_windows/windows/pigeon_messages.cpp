// Copyright 2025 The Pro Video Player Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.7.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include "pigeon_messages.h"

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

namespace pro_video_player {
using flutter::BasicMessageChannel;
using flutter::CustomEncodableValue;
using flutter::EncodableList;
using flutter::EncodableMap;
using flutter::EncodableValue;

FlutterError CreateConnectionError(const std::string channel_name) {
  return FlutterError(
      "channel-error",
      "Unable to establish connection on channel: '" + channel_name + "'.",
      EncodableValue(""));
}

// VideoSourceMessage

VideoSourceMessage::VideoSourceMessage(const VideoSourceType& type)
 : type_(type) {}

VideoSourceMessage::VideoSourceMessage(
  const VideoSourceType& type,
  const std::string* url,
  const std::string* path,
  const std::string* asset_path,
  const EncodableMap* headers)
 : type_(type),
    url_(url ? std::optional<std::string>(*url) : std::nullopt),
    path_(path ? std::optional<std::string>(*path) : std::nullopt),
    asset_path_(asset_path ? std::optional<std::string>(*asset_path) : std::nullopt),
    headers_(headers ? std::optional<EncodableMap>(*headers) : std::nullopt) {}

const VideoSourceType& VideoSourceMessage::type() const {
  return type_;
}

void VideoSourceMessage::set_type(const VideoSourceType& value_arg) {
  type_ = value_arg;
}


const std::string* VideoSourceMessage::url() const {
  return url_ ? &(*url_) : nullptr;
}

void VideoSourceMessage::set_url(const std::string_view* value_arg) {
  url_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoSourceMessage::set_url(std::string_view value_arg) {
  url_ = value_arg;
}


const std::string* VideoSourceMessage::path() const {
  return path_ ? &(*path_) : nullptr;
}

void VideoSourceMessage::set_path(const std::string_view* value_arg) {
  path_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoSourceMessage::set_path(std::string_view value_arg) {
  path_ = value_arg;
}


const std::string* VideoSourceMessage::asset_path() const {
  return asset_path_ ? &(*asset_path_) : nullptr;
}

void VideoSourceMessage::set_asset_path(const std::string_view* value_arg) {
  asset_path_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoSourceMessage::set_asset_path(std::string_view value_arg) {
  asset_path_ = value_arg;
}


const EncodableMap* VideoSourceMessage::headers() const {
  return headers_ ? &(*headers_) : nullptr;
}

void VideoSourceMessage::set_headers(const EncodableMap* value_arg) {
  headers_ = value_arg ? std::optional<EncodableMap>(*value_arg) : std::nullopt;
}

void VideoSourceMessage::set_headers(const EncodableMap& value_arg) {
  headers_ = value_arg;
}


EncodableList VideoSourceMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(CustomEncodableValue(type_));
  list.push_back(url_ ? EncodableValue(*url_) : EncodableValue());
  list.push_back(path_ ? EncodableValue(*path_) : EncodableValue());
  list.push_back(asset_path_ ? EncodableValue(*asset_path_) : EncodableValue());
  list.push_back(headers_ ? EncodableValue(*headers_) : EncodableValue());
  return list;
}

VideoSourceMessage VideoSourceMessage::FromEncodableList(const EncodableList& list) {
  VideoSourceMessage decoded(
    std::any_cast<const VideoSourceType&>(std::get<CustomEncodableValue>(list[0])));
  auto& encodable_url = list[1];
  if (!encodable_url.IsNull()) {
    decoded.set_url(std::get<std::string>(encodable_url));
  }
  auto& encodable_path = list[2];
  if (!encodable_path.IsNull()) {
    decoded.set_path(std::get<std::string>(encodable_path));
  }
  auto& encodable_asset_path = list[3];
  if (!encodable_asset_path.IsNull()) {
    decoded.set_asset_path(std::get<std::string>(encodable_asset_path));
  }
  auto& encodable_headers = list[4];
  if (!encodable_headers.IsNull()) {
    decoded.set_headers(std::get<EncodableMap>(encodable_headers));
  }
  return decoded;
}

// VideoPlayerOptionsMessage

VideoPlayerOptionsMessage::VideoPlayerOptionsMessage(
  bool auto_play,
  bool looping,
  double volume,
  double playback_speed,
  bool allow_background_playback,
  bool mix_with_others,
  bool allow_pip,
  bool auto_enter_pip_on_background)
 : auto_play_(auto_play),
    looping_(looping),
    volume_(volume),
    playback_speed_(playback_speed),
    allow_background_playback_(allow_background_playback),
    mix_with_others_(mix_with_others),
    allow_pip_(allow_pip),
    auto_enter_pip_on_background_(auto_enter_pip_on_background) {}

VideoPlayerOptionsMessage::VideoPlayerOptionsMessage(
  bool auto_play,
  bool looping,
  double volume,
  double playback_speed,
  const int64_t* start_position,
  const bool* enable_pip,
  const bool* enable_background_playback,
  const std::string* preferred_audio_language,
  const std::string* preferred_subtitle_language,
  const int64_t* max_bitrate,
  const int64_t* min_bitrate,
  const std::string* preferred_audio_rendition,
  bool allow_background_playback,
  bool mix_with_others,
  bool allow_pip,
  bool auto_enter_pip_on_background)
 : auto_play_(auto_play),
    looping_(looping),
    volume_(volume),
    playback_speed_(playback_speed),
    start_position_(start_position ? std::optional<int64_t>(*start_position) : std::nullopt),
    enable_pip_(enable_pip ? std::optional<bool>(*enable_pip) : std::nullopt),
    enable_background_playback_(enable_background_playback ? std::optional<bool>(*enable_background_playback) : std::nullopt),
    preferred_audio_language_(preferred_audio_language ? std::optional<std::string>(*preferred_audio_language) : std::nullopt),
    preferred_subtitle_language_(preferred_subtitle_language ? std::optional<std::string>(*preferred_subtitle_language) : std::nullopt),
    max_bitrate_(max_bitrate ? std::optional<int64_t>(*max_bitrate) : std::nullopt),
    min_bitrate_(min_bitrate ? std::optional<int64_t>(*min_bitrate) : std::nullopt),
    preferred_audio_rendition_(preferred_audio_rendition ? std::optional<std::string>(*preferred_audio_rendition) : std::nullopt),
    allow_background_playback_(allow_background_playback),
    mix_with_others_(mix_with_others),
    allow_pip_(allow_pip),
    auto_enter_pip_on_background_(auto_enter_pip_on_background) {}

bool VideoPlayerOptionsMessage::auto_play() const {
  return auto_play_;
}

void VideoPlayerOptionsMessage::set_auto_play(bool value_arg) {
  auto_play_ = value_arg;
}


bool VideoPlayerOptionsMessage::looping() const {
  return looping_;
}

void VideoPlayerOptionsMessage::set_looping(bool value_arg) {
  looping_ = value_arg;
}


double VideoPlayerOptionsMessage::volume() const {
  return volume_;
}

void VideoPlayerOptionsMessage::set_volume(double value_arg) {
  volume_ = value_arg;
}


double VideoPlayerOptionsMessage::playback_speed() const {
  return playback_speed_;
}

void VideoPlayerOptionsMessage::set_playback_speed(double value_arg) {
  playback_speed_ = value_arg;
}


const int64_t* VideoPlayerOptionsMessage::start_position() const {
  return start_position_ ? &(*start_position_) : nullptr;
}

void VideoPlayerOptionsMessage::set_start_position(const int64_t* value_arg) {
  start_position_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoPlayerOptionsMessage::set_start_position(int64_t value_arg) {
  start_position_ = value_arg;
}


const bool* VideoPlayerOptionsMessage::enable_pip() const {
  return enable_pip_ ? &(*enable_pip_) : nullptr;
}

void VideoPlayerOptionsMessage::set_enable_pip(const bool* value_arg) {
  enable_pip_ = value_arg ? std::optional<bool>(*value_arg) : std::nullopt;
}

void VideoPlayerOptionsMessage::set_enable_pip(bool value_arg) {
  enable_pip_ = value_arg;
}


const bool* VideoPlayerOptionsMessage::enable_background_playback() const {
  return enable_background_playback_ ? &(*enable_background_playback_) : nullptr;
}

void VideoPlayerOptionsMessage::set_enable_background_playback(const bool* value_arg) {
  enable_background_playback_ = value_arg ? std::optional<bool>(*value_arg) : std::nullopt;
}

void VideoPlayerOptionsMessage::set_enable_background_playback(bool value_arg) {
  enable_background_playback_ = value_arg;
}


const std::string* VideoPlayerOptionsMessage::preferred_audio_language() const {
  return preferred_audio_language_ ? &(*preferred_audio_language_) : nullptr;
}

void VideoPlayerOptionsMessage::set_preferred_audio_language(const std::string_view* value_arg) {
  preferred_audio_language_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoPlayerOptionsMessage::set_preferred_audio_language(std::string_view value_arg) {
  preferred_audio_language_ = value_arg;
}


const std::string* VideoPlayerOptionsMessage::preferred_subtitle_language() const {
  return preferred_subtitle_language_ ? &(*preferred_subtitle_language_) : nullptr;
}

void VideoPlayerOptionsMessage::set_preferred_subtitle_language(const std::string_view* value_arg) {
  preferred_subtitle_language_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoPlayerOptionsMessage::set_preferred_subtitle_language(std::string_view value_arg) {
  preferred_subtitle_language_ = value_arg;
}


const int64_t* VideoPlayerOptionsMessage::max_bitrate() const {
  return max_bitrate_ ? &(*max_bitrate_) : nullptr;
}

void VideoPlayerOptionsMessage::set_max_bitrate(const int64_t* value_arg) {
  max_bitrate_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoPlayerOptionsMessage::set_max_bitrate(int64_t value_arg) {
  max_bitrate_ = value_arg;
}


const int64_t* VideoPlayerOptionsMessage::min_bitrate() const {
  return min_bitrate_ ? &(*min_bitrate_) : nullptr;
}

void VideoPlayerOptionsMessage::set_min_bitrate(const int64_t* value_arg) {
  min_bitrate_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoPlayerOptionsMessage::set_min_bitrate(int64_t value_arg) {
  min_bitrate_ = value_arg;
}


const std::string* VideoPlayerOptionsMessage::preferred_audio_rendition() const {
  return preferred_audio_rendition_ ? &(*preferred_audio_rendition_) : nullptr;
}

void VideoPlayerOptionsMessage::set_preferred_audio_rendition(const std::string_view* value_arg) {
  preferred_audio_rendition_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoPlayerOptionsMessage::set_preferred_audio_rendition(std::string_view value_arg) {
  preferred_audio_rendition_ = value_arg;
}


bool VideoPlayerOptionsMessage::allow_background_playback() const {
  return allow_background_playback_;
}

void VideoPlayerOptionsMessage::set_allow_background_playback(bool value_arg) {
  allow_background_playback_ = value_arg;
}


bool VideoPlayerOptionsMessage::mix_with_others() const {
  return mix_with_others_;
}

void VideoPlayerOptionsMessage::set_mix_with_others(bool value_arg) {
  mix_with_others_ = value_arg;
}


bool VideoPlayerOptionsMessage::allow_pip() const {
  return allow_pip_;
}

void VideoPlayerOptionsMessage::set_allow_pip(bool value_arg) {
  allow_pip_ = value_arg;
}


bool VideoPlayerOptionsMessage::auto_enter_pip_on_background() const {
  return auto_enter_pip_on_background_;
}

void VideoPlayerOptionsMessage::set_auto_enter_pip_on_background(bool value_arg) {
  auto_enter_pip_on_background_ = value_arg;
}


EncodableList VideoPlayerOptionsMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(16);
  list.push_back(EncodableValue(auto_play_));
  list.push_back(EncodableValue(looping_));
  list.push_back(EncodableValue(volume_));
  list.push_back(EncodableValue(playback_speed_));
  list.push_back(start_position_ ? EncodableValue(*start_position_) : EncodableValue());
  list.push_back(enable_pip_ ? EncodableValue(*enable_pip_) : EncodableValue());
  list.push_back(enable_background_playback_ ? EncodableValue(*enable_background_playback_) : EncodableValue());
  list.push_back(preferred_audio_language_ ? EncodableValue(*preferred_audio_language_) : EncodableValue());
  list.push_back(preferred_subtitle_language_ ? EncodableValue(*preferred_subtitle_language_) : EncodableValue());
  list.push_back(max_bitrate_ ? EncodableValue(*max_bitrate_) : EncodableValue());
  list.push_back(min_bitrate_ ? EncodableValue(*min_bitrate_) : EncodableValue());
  list.push_back(preferred_audio_rendition_ ? EncodableValue(*preferred_audio_rendition_) : EncodableValue());
  list.push_back(EncodableValue(allow_background_playback_));
  list.push_back(EncodableValue(mix_with_others_));
  list.push_back(EncodableValue(allow_pip_));
  list.push_back(EncodableValue(auto_enter_pip_on_background_));
  return list;
}

VideoPlayerOptionsMessage VideoPlayerOptionsMessage::FromEncodableList(const EncodableList& list) {
  VideoPlayerOptionsMessage decoded(
    std::get<bool>(list[0]),
    std::get<bool>(list[1]),
    std::get<double>(list[2]),
    std::get<double>(list[3]),
    std::get<bool>(list[12]),
    std::get<bool>(list[13]),
    std::get<bool>(list[14]),
    std::get<bool>(list[15]));
  auto& encodable_start_position = list[4];
  if (!encodable_start_position.IsNull()) {
    decoded.set_start_position(std::get<int64_t>(encodable_start_position));
  }
  auto& encodable_enable_pip = list[5];
  if (!encodable_enable_pip.IsNull()) {
    decoded.set_enable_pip(std::get<bool>(encodable_enable_pip));
  }
  auto& encodable_enable_background_playback = list[6];
  if (!encodable_enable_background_playback.IsNull()) {
    decoded.set_enable_background_playback(std::get<bool>(encodable_enable_background_playback));
  }
  auto& encodable_preferred_audio_language = list[7];
  if (!encodable_preferred_audio_language.IsNull()) {
    decoded.set_preferred_audio_language(std::get<std::string>(encodable_preferred_audio_language));
  }
  auto& encodable_preferred_subtitle_language = list[8];
  if (!encodable_preferred_subtitle_language.IsNull()) {
    decoded.set_preferred_subtitle_language(std::get<std::string>(encodable_preferred_subtitle_language));
  }
  auto& encodable_max_bitrate = list[9];
  if (!encodable_max_bitrate.IsNull()) {
    decoded.set_max_bitrate(std::get<int64_t>(encodable_max_bitrate));
  }
  auto& encodable_min_bitrate = list[10];
  if (!encodable_min_bitrate.IsNull()) {
    decoded.set_min_bitrate(std::get<int64_t>(encodable_min_bitrate));
  }
  auto& encodable_preferred_audio_rendition = list[11];
  if (!encodable_preferred_audio_rendition.IsNull()) {
    decoded.set_preferred_audio_rendition(std::get<std::string>(encodable_preferred_audio_rendition));
  }
  return decoded;
}

// PlatformInfoMessage

PlatformInfoMessage::PlatformInfoMessage(
  const std::string& platform_name,
  const std::string& native_player_type)
 : platform_name_(platform_name),
    native_player_type_(native_player_type) {}

PlatformInfoMessage::PlatformInfoMessage(
  const std::string& platform_name,
  const std::string& native_player_type,
  const EncodableMap* additional_info)
 : platform_name_(platform_name),
    native_player_type_(native_player_type),
    additional_info_(additional_info ? std::optional<EncodableMap>(*additional_info) : std::nullopt) {}

const std::string& PlatformInfoMessage::platform_name() const {
  return platform_name_;
}

void PlatformInfoMessage::set_platform_name(std::string_view value_arg) {
  platform_name_ = value_arg;
}


const std::string& PlatformInfoMessage::native_player_type() const {
  return native_player_type_;
}

void PlatformInfoMessage::set_native_player_type(std::string_view value_arg) {
  native_player_type_ = value_arg;
}


const EncodableMap* PlatformInfoMessage::additional_info() const {
  return additional_info_ ? &(*additional_info_) : nullptr;
}

void PlatformInfoMessage::set_additional_info(const EncodableMap* value_arg) {
  additional_info_ = value_arg ? std::optional<EncodableMap>(*value_arg) : std::nullopt;
}

void PlatformInfoMessage::set_additional_info(const EncodableMap& value_arg) {
  additional_info_ = value_arg;
}


EncodableList PlatformInfoMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(EncodableValue(platform_name_));
  list.push_back(EncodableValue(native_player_type_));
  list.push_back(additional_info_ ? EncodableValue(*additional_info_) : EncodableValue());
  return list;
}

PlatformInfoMessage PlatformInfoMessage::FromEncodableList(const EncodableList& list) {
  PlatformInfoMessage decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]));
  auto& encodable_additional_info = list[2];
  if (!encodable_additional_info.IsNull()) {
    decoded.set_additional_info(std::get<EncodableMap>(encodable_additional_info));
  }
  return decoded;
}

// BatteryInfoMessage

BatteryInfoMessage::BatteryInfoMessage(
  int64_t percentage,
  bool is_charging)
 : percentage_(percentage),
    is_charging_(is_charging) {}

int64_t BatteryInfoMessage::percentage() const {
  return percentage_;
}

void BatteryInfoMessage::set_percentage(int64_t value_arg) {
  percentage_ = value_arg;
}


bool BatteryInfoMessage::is_charging() const {
  return is_charging_;
}

void BatteryInfoMessage::set_is_charging(bool value_arg) {
  is_charging_ = value_arg;
}


EncodableList BatteryInfoMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(percentage_));
  list.push_back(EncodableValue(is_charging_));
  return list;
}

BatteryInfoMessage BatteryInfoMessage::FromEncodableList(const EncodableList& list) {
  BatteryInfoMessage decoded(
    std::get<int64_t>(list[0]),
    std::get<bool>(list[1]));
  return decoded;
}

// SubtitleTrackMessage

SubtitleTrackMessage::SubtitleTrackMessage(const std::string& id)
 : id_(id) {}

SubtitleTrackMessage::SubtitleTrackMessage(
  const std::string& id,
  const std::string* label,
  const std::string* language,
  const SubtitleFormatEnum* format,
  const bool* is_default)
 : id_(id),
    label_(label ? std::optional<std::string>(*label) : std::nullopt),
    language_(language ? std::optional<std::string>(*language) : std::nullopt),
    format_(format ? std::optional<SubtitleFormatEnum>(*format) : std::nullopt),
    is_default_(is_default ? std::optional<bool>(*is_default) : std::nullopt) {}

const std::string& SubtitleTrackMessage::id() const {
  return id_;
}

void SubtitleTrackMessage::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const std::string* SubtitleTrackMessage::label() const {
  return label_ ? &(*label_) : nullptr;
}

void SubtitleTrackMessage::set_label(const std::string_view* value_arg) {
  label_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void SubtitleTrackMessage::set_label(std::string_view value_arg) {
  label_ = value_arg;
}


const std::string* SubtitleTrackMessage::language() const {
  return language_ ? &(*language_) : nullptr;
}

void SubtitleTrackMessage::set_language(const std::string_view* value_arg) {
  language_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void SubtitleTrackMessage::set_language(std::string_view value_arg) {
  language_ = value_arg;
}


const SubtitleFormatEnum* SubtitleTrackMessage::format() const {
  return format_ ? &(*format_) : nullptr;
}

void SubtitleTrackMessage::set_format(const SubtitleFormatEnum* value_arg) {
  format_ = value_arg ? std::optional<SubtitleFormatEnum>(*value_arg) : std::nullopt;
}

void SubtitleTrackMessage::set_format(const SubtitleFormatEnum& value_arg) {
  format_ = value_arg;
}


const bool* SubtitleTrackMessage::is_default() const {
  return is_default_ ? &(*is_default_) : nullptr;
}

void SubtitleTrackMessage::set_is_default(const bool* value_arg) {
  is_default_ = value_arg ? std::optional<bool>(*value_arg) : std::nullopt;
}

void SubtitleTrackMessage::set_is_default(bool value_arg) {
  is_default_ = value_arg;
}


EncodableList SubtitleTrackMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(EncodableValue(id_));
  list.push_back(label_ ? EncodableValue(*label_) : EncodableValue());
  list.push_back(language_ ? EncodableValue(*language_) : EncodableValue());
  list.push_back(format_ ? CustomEncodableValue(*format_) : EncodableValue());
  list.push_back(is_default_ ? EncodableValue(*is_default_) : EncodableValue());
  return list;
}

SubtitleTrackMessage SubtitleTrackMessage::FromEncodableList(const EncodableList& list) {
  SubtitleTrackMessage decoded(
    std::get<std::string>(list[0]));
  auto& encodable_label = list[1];
  if (!encodable_label.IsNull()) {
    decoded.set_label(std::get<std::string>(encodable_label));
  }
  auto& encodable_language = list[2];
  if (!encodable_language.IsNull()) {
    decoded.set_language(std::get<std::string>(encodable_language));
  }
  auto& encodable_format = list[3];
  if (!encodable_format.IsNull()) {
    decoded.set_format(std::any_cast<const SubtitleFormatEnum&>(std::get<CustomEncodableValue>(encodable_format)));
  }
  auto& encodable_is_default = list[4];
  if (!encodable_is_default.IsNull()) {
    decoded.set_is_default(std::get<bool>(encodable_is_default));
  }
  return decoded;
}

// AudioTrackMessage

AudioTrackMessage::AudioTrackMessage(const std::string& id)
 : id_(id) {}

AudioTrackMessage::AudioTrackMessage(
  const std::string& id,
  const std::string* label,
  const std::string* language,
  const int64_t* channel_count,
  const bool* is_default)
 : id_(id),
    label_(label ? std::optional<std::string>(*label) : std::nullopt),
    language_(language ? std::optional<std::string>(*language) : std::nullopt),
    channel_count_(channel_count ? std::optional<int64_t>(*channel_count) : std::nullopt),
    is_default_(is_default ? std::optional<bool>(*is_default) : std::nullopt) {}

const std::string& AudioTrackMessage::id() const {
  return id_;
}

void AudioTrackMessage::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const std::string* AudioTrackMessage::label() const {
  return label_ ? &(*label_) : nullptr;
}

void AudioTrackMessage::set_label(const std::string_view* value_arg) {
  label_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void AudioTrackMessage::set_label(std::string_view value_arg) {
  label_ = value_arg;
}


const std::string* AudioTrackMessage::language() const {
  return language_ ? &(*language_) : nullptr;
}

void AudioTrackMessage::set_language(const std::string_view* value_arg) {
  language_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void AudioTrackMessage::set_language(std::string_view value_arg) {
  language_ = value_arg;
}


const int64_t* AudioTrackMessage::channel_count() const {
  return channel_count_ ? &(*channel_count_) : nullptr;
}

void AudioTrackMessage::set_channel_count(const int64_t* value_arg) {
  channel_count_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void AudioTrackMessage::set_channel_count(int64_t value_arg) {
  channel_count_ = value_arg;
}


const bool* AudioTrackMessage::is_default() const {
  return is_default_ ? &(*is_default_) : nullptr;
}

void AudioTrackMessage::set_is_default(const bool* value_arg) {
  is_default_ = value_arg ? std::optional<bool>(*value_arg) : std::nullopt;
}

void AudioTrackMessage::set_is_default(bool value_arg) {
  is_default_ = value_arg;
}


EncodableList AudioTrackMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(EncodableValue(id_));
  list.push_back(label_ ? EncodableValue(*label_) : EncodableValue());
  list.push_back(language_ ? EncodableValue(*language_) : EncodableValue());
  list.push_back(channel_count_ ? EncodableValue(*channel_count_) : EncodableValue());
  list.push_back(is_default_ ? EncodableValue(*is_default_) : EncodableValue());
  return list;
}

AudioTrackMessage AudioTrackMessage::FromEncodableList(const EncodableList& list) {
  AudioTrackMessage decoded(
    std::get<std::string>(list[0]));
  auto& encodable_label = list[1];
  if (!encodable_label.IsNull()) {
    decoded.set_label(std::get<std::string>(encodable_label));
  }
  auto& encodable_language = list[2];
  if (!encodable_language.IsNull()) {
    decoded.set_language(std::get<std::string>(encodable_language));
  }
  auto& encodable_channel_count = list[3];
  if (!encodable_channel_count.IsNull()) {
    decoded.set_channel_count(std::get<int64_t>(encodable_channel_count));
  }
  auto& encodable_is_default = list[4];
  if (!encodable_is_default.IsNull()) {
    decoded.set_is_default(std::get<bool>(encodable_is_default));
  }
  return decoded;
}

// VideoQualityTrackMessage

VideoQualityTrackMessage::VideoQualityTrackMessage(const std::string& id)
 : id_(id) {}

VideoQualityTrackMessage::VideoQualityTrackMessage(
  const std::string& id,
  const std::string* label,
  const int64_t* bitrate,
  const int64_t* width,
  const int64_t* height,
  const std::string* codec,
  const bool* is_default)
 : id_(id),
    label_(label ? std::optional<std::string>(*label) : std::nullopt),
    bitrate_(bitrate ? std::optional<int64_t>(*bitrate) : std::nullopt),
    width_(width ? std::optional<int64_t>(*width) : std::nullopt),
    height_(height ? std::optional<int64_t>(*height) : std::nullopt),
    codec_(codec ? std::optional<std::string>(*codec) : std::nullopt),
    is_default_(is_default ? std::optional<bool>(*is_default) : std::nullopt) {}

const std::string& VideoQualityTrackMessage::id() const {
  return id_;
}

void VideoQualityTrackMessage::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const std::string* VideoQualityTrackMessage::label() const {
  return label_ ? &(*label_) : nullptr;
}

void VideoQualityTrackMessage::set_label(const std::string_view* value_arg) {
  label_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoQualityTrackMessage::set_label(std::string_view value_arg) {
  label_ = value_arg;
}


const int64_t* VideoQualityTrackMessage::bitrate() const {
  return bitrate_ ? &(*bitrate_) : nullptr;
}

void VideoQualityTrackMessage::set_bitrate(const int64_t* value_arg) {
  bitrate_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoQualityTrackMessage::set_bitrate(int64_t value_arg) {
  bitrate_ = value_arg;
}


const int64_t* VideoQualityTrackMessage::width() const {
  return width_ ? &(*width_) : nullptr;
}

void VideoQualityTrackMessage::set_width(const int64_t* value_arg) {
  width_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoQualityTrackMessage::set_width(int64_t value_arg) {
  width_ = value_arg;
}


const int64_t* VideoQualityTrackMessage::height() const {
  return height_ ? &(*height_) : nullptr;
}

void VideoQualityTrackMessage::set_height(const int64_t* value_arg) {
  height_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoQualityTrackMessage::set_height(int64_t value_arg) {
  height_ = value_arg;
}


const std::string* VideoQualityTrackMessage::codec() const {
  return codec_ ? &(*codec_) : nullptr;
}

void VideoQualityTrackMessage::set_codec(const std::string_view* value_arg) {
  codec_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoQualityTrackMessage::set_codec(std::string_view value_arg) {
  codec_ = value_arg;
}


const bool* VideoQualityTrackMessage::is_default() const {
  return is_default_ ? &(*is_default_) : nullptr;
}

void VideoQualityTrackMessage::set_is_default(const bool* value_arg) {
  is_default_ = value_arg ? std::optional<bool>(*value_arg) : std::nullopt;
}

void VideoQualityTrackMessage::set_is_default(bool value_arg) {
  is_default_ = value_arg;
}


EncodableList VideoQualityTrackMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(7);
  list.push_back(EncodableValue(id_));
  list.push_back(label_ ? EncodableValue(*label_) : EncodableValue());
  list.push_back(bitrate_ ? EncodableValue(*bitrate_) : EncodableValue());
  list.push_back(width_ ? EncodableValue(*width_) : EncodableValue());
  list.push_back(height_ ? EncodableValue(*height_) : EncodableValue());
  list.push_back(codec_ ? EncodableValue(*codec_) : EncodableValue());
  list.push_back(is_default_ ? EncodableValue(*is_default_) : EncodableValue());
  return list;
}

VideoQualityTrackMessage VideoQualityTrackMessage::FromEncodableList(const EncodableList& list) {
  VideoQualityTrackMessage decoded(
    std::get<std::string>(list[0]));
  auto& encodable_label = list[1];
  if (!encodable_label.IsNull()) {
    decoded.set_label(std::get<std::string>(encodable_label));
  }
  auto& encodable_bitrate = list[2];
  if (!encodable_bitrate.IsNull()) {
    decoded.set_bitrate(std::get<int64_t>(encodable_bitrate));
  }
  auto& encodable_width = list[3];
  if (!encodable_width.IsNull()) {
    decoded.set_width(std::get<int64_t>(encodable_width));
  }
  auto& encodable_height = list[4];
  if (!encodable_height.IsNull()) {
    decoded.set_height(std::get<int64_t>(encodable_height));
  }
  auto& encodable_codec = list[5];
  if (!encodable_codec.IsNull()) {
    decoded.set_codec(std::get<std::string>(encodable_codec));
  }
  auto& encodable_is_default = list[6];
  if (!encodable_is_default.IsNull()) {
    decoded.set_is_default(std::get<bool>(encodable_is_default));
  }
  return decoded;
}

// PipOptionsMessage

PipOptionsMessage::PipOptionsMessage(bool auto_enter_on_background)
 : auto_enter_on_background_(auto_enter_on_background) {}

PipOptionsMessage::PipOptionsMessage(
  const double* aspect_ratio,
  bool auto_enter_on_background)
 : aspect_ratio_(aspect_ratio ? std::optional<double>(*aspect_ratio) : std::nullopt),
    auto_enter_on_background_(auto_enter_on_background) {}

const double* PipOptionsMessage::aspect_ratio() const {
  return aspect_ratio_ ? &(*aspect_ratio_) : nullptr;
}

void PipOptionsMessage::set_aspect_ratio(const double* value_arg) {
  aspect_ratio_ = value_arg ? std::optional<double>(*value_arg) : std::nullopt;
}

void PipOptionsMessage::set_aspect_ratio(double value_arg) {
  aspect_ratio_ = value_arg;
}


bool PipOptionsMessage::auto_enter_on_background() const {
  return auto_enter_on_background_;
}

void PipOptionsMessage::set_auto_enter_on_background(bool value_arg) {
  auto_enter_on_background_ = value_arg;
}


EncodableList PipOptionsMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(aspect_ratio_ ? EncodableValue(*aspect_ratio_) : EncodableValue());
  list.push_back(EncodableValue(auto_enter_on_background_));
  return list;
}

PipOptionsMessage PipOptionsMessage::FromEncodableList(const EncodableList& list) {
  PipOptionsMessage decoded(
    std::get<bool>(list[1]));
  auto& encodable_aspect_ratio = list[0];
  if (!encodable_aspect_ratio.IsNull()) {
    decoded.set_aspect_ratio(std::get<double>(encodable_aspect_ratio));
  }
  return decoded;
}

// PipActionMessage

PipActionMessage::PipActionMessage(const PipActionTypeEnum& type)
 : type_(type) {}

PipActionMessage::PipActionMessage(
  const PipActionTypeEnum& type,
  const std::string* title,
  const std::string* icon_name,
  const int64_t* skip_interval_ms)
 : type_(type),
    title_(title ? std::optional<std::string>(*title) : std::nullopt),
    icon_name_(icon_name ? std::optional<std::string>(*icon_name) : std::nullopt),
    skip_interval_ms_(skip_interval_ms ? std::optional<int64_t>(*skip_interval_ms) : std::nullopt) {}

const PipActionTypeEnum& PipActionMessage::type() const {
  return type_;
}

void PipActionMessage::set_type(const PipActionTypeEnum& value_arg) {
  type_ = value_arg;
}


const std::string* PipActionMessage::title() const {
  return title_ ? &(*title_) : nullptr;
}

void PipActionMessage::set_title(const std::string_view* value_arg) {
  title_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PipActionMessage::set_title(std::string_view value_arg) {
  title_ = value_arg;
}


const std::string* PipActionMessage::icon_name() const {
  return icon_name_ ? &(*icon_name_) : nullptr;
}

void PipActionMessage::set_icon_name(const std::string_view* value_arg) {
  icon_name_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void PipActionMessage::set_icon_name(std::string_view value_arg) {
  icon_name_ = value_arg;
}


const int64_t* PipActionMessage::skip_interval_ms() const {
  return skip_interval_ms_ ? &(*skip_interval_ms_) : nullptr;
}

void PipActionMessage::set_skip_interval_ms(const int64_t* value_arg) {
  skip_interval_ms_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void PipActionMessage::set_skip_interval_ms(int64_t value_arg) {
  skip_interval_ms_ = value_arg;
}


EncodableList PipActionMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(CustomEncodableValue(type_));
  list.push_back(title_ ? EncodableValue(*title_) : EncodableValue());
  list.push_back(icon_name_ ? EncodableValue(*icon_name_) : EncodableValue());
  list.push_back(skip_interval_ms_ ? EncodableValue(*skip_interval_ms_) : EncodableValue());
  return list;
}

PipActionMessage PipActionMessage::FromEncodableList(const EncodableList& list) {
  PipActionMessage decoded(
    std::any_cast<const PipActionTypeEnum&>(std::get<CustomEncodableValue>(list[0])));
  auto& encodable_title = list[1];
  if (!encodable_title.IsNull()) {
    decoded.set_title(std::get<std::string>(encodable_title));
  }
  auto& encodable_icon_name = list[2];
  if (!encodable_icon_name.IsNull()) {
    decoded.set_icon_name(std::get<std::string>(encodable_icon_name));
  }
  auto& encodable_skip_interval_ms = list[3];
  if (!encodable_skip_interval_ms.IsNull()) {
    decoded.set_skip_interval_ms(std::get<int64_t>(encodable_skip_interval_ms));
  }
  return decoded;
}

// CastDeviceMessage

CastDeviceMessage::CastDeviceMessage(
  const std::string& id,
  const std::string& name,
  const CastDeviceTypeEnum& type)
 : id_(id),
    name_(name),
    type_(type) {}

const std::string& CastDeviceMessage::id() const {
  return id_;
}

void CastDeviceMessage::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const std::string& CastDeviceMessage::name() const {
  return name_;
}

void CastDeviceMessage::set_name(std::string_view value_arg) {
  name_ = value_arg;
}


const CastDeviceTypeEnum& CastDeviceMessage::type() const {
  return type_;
}

void CastDeviceMessage::set_type(const CastDeviceTypeEnum& value_arg) {
  type_ = value_arg;
}


EncodableList CastDeviceMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(EncodableValue(id_));
  list.push_back(EncodableValue(name_));
  list.push_back(CustomEncodableValue(type_));
  return list;
}

CastDeviceMessage CastDeviceMessage::FromEncodableList(const EncodableList& list) {
  CastDeviceMessage decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    std::any_cast<const CastDeviceTypeEnum&>(std::get<CustomEncodableValue>(list[2])));
  return decoded;
}

// VideoMetadataMessage

VideoMetadataMessage::VideoMetadataMessage() {}

VideoMetadataMessage::VideoMetadataMessage(
  const int64_t* duration,
  const int64_t* width,
  const int64_t* height,
  const std::string* video_codec,
  const std::string* audio_codec,
  const int64_t* bitrate,
  const double* frame_rate)
 : duration_(duration ? std::optional<int64_t>(*duration) : std::nullopt),
    width_(width ? std::optional<int64_t>(*width) : std::nullopt),
    height_(height ? std::optional<int64_t>(*height) : std::nullopt),
    video_codec_(video_codec ? std::optional<std::string>(*video_codec) : std::nullopt),
    audio_codec_(audio_codec ? std::optional<std::string>(*audio_codec) : std::nullopt),
    bitrate_(bitrate ? std::optional<int64_t>(*bitrate) : std::nullopt),
    frame_rate_(frame_rate ? std::optional<double>(*frame_rate) : std::nullopt) {}

const int64_t* VideoMetadataMessage::duration() const {
  return duration_ ? &(*duration_) : nullptr;
}

void VideoMetadataMessage::set_duration(const int64_t* value_arg) {
  duration_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoMetadataMessage::set_duration(int64_t value_arg) {
  duration_ = value_arg;
}


const int64_t* VideoMetadataMessage::width() const {
  return width_ ? &(*width_) : nullptr;
}

void VideoMetadataMessage::set_width(const int64_t* value_arg) {
  width_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoMetadataMessage::set_width(int64_t value_arg) {
  width_ = value_arg;
}


const int64_t* VideoMetadataMessage::height() const {
  return height_ ? &(*height_) : nullptr;
}

void VideoMetadataMessage::set_height(const int64_t* value_arg) {
  height_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoMetadataMessage::set_height(int64_t value_arg) {
  height_ = value_arg;
}


const std::string* VideoMetadataMessage::video_codec() const {
  return video_codec_ ? &(*video_codec_) : nullptr;
}

void VideoMetadataMessage::set_video_codec(const std::string_view* value_arg) {
  video_codec_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoMetadataMessage::set_video_codec(std::string_view value_arg) {
  video_codec_ = value_arg;
}


const std::string* VideoMetadataMessage::audio_codec() const {
  return audio_codec_ ? &(*audio_codec_) : nullptr;
}

void VideoMetadataMessage::set_audio_codec(const std::string_view* value_arg) {
  audio_codec_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoMetadataMessage::set_audio_codec(std::string_view value_arg) {
  audio_codec_ = value_arg;
}


const int64_t* VideoMetadataMessage::bitrate() const {
  return bitrate_ ? &(*bitrate_) : nullptr;
}

void VideoMetadataMessage::set_bitrate(const int64_t* value_arg) {
  bitrate_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoMetadataMessage::set_bitrate(int64_t value_arg) {
  bitrate_ = value_arg;
}


const double* VideoMetadataMessage::frame_rate() const {
  return frame_rate_ ? &(*frame_rate_) : nullptr;
}

void VideoMetadataMessage::set_frame_rate(const double* value_arg) {
  frame_rate_ = value_arg ? std::optional<double>(*value_arg) : std::nullopt;
}

void VideoMetadataMessage::set_frame_rate(double value_arg) {
  frame_rate_ = value_arg;
}


EncodableList VideoMetadataMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(7);
  list.push_back(duration_ ? EncodableValue(*duration_) : EncodableValue());
  list.push_back(width_ ? EncodableValue(*width_) : EncodableValue());
  list.push_back(height_ ? EncodableValue(*height_) : EncodableValue());
  list.push_back(video_codec_ ? EncodableValue(*video_codec_) : EncodableValue());
  list.push_back(audio_codec_ ? EncodableValue(*audio_codec_) : EncodableValue());
  list.push_back(bitrate_ ? EncodableValue(*bitrate_) : EncodableValue());
  list.push_back(frame_rate_ ? EncodableValue(*frame_rate_) : EncodableValue());
  return list;
}

VideoMetadataMessage VideoMetadataMessage::FromEncodableList(const EncodableList& list) {
  VideoMetadataMessage decoded;
  auto& encodable_duration = list[0];
  if (!encodable_duration.IsNull()) {
    decoded.set_duration(std::get<int64_t>(encodable_duration));
  }
  auto& encodable_width = list[1];
  if (!encodable_width.IsNull()) {
    decoded.set_width(std::get<int64_t>(encodable_width));
  }
  auto& encodable_height = list[2];
  if (!encodable_height.IsNull()) {
    decoded.set_height(std::get<int64_t>(encodable_height));
  }
  auto& encodable_video_codec = list[3];
  if (!encodable_video_codec.IsNull()) {
    decoded.set_video_codec(std::get<std::string>(encodable_video_codec));
  }
  auto& encodable_audio_codec = list[4];
  if (!encodable_audio_codec.IsNull()) {
    decoded.set_audio_codec(std::get<std::string>(encodable_audio_codec));
  }
  auto& encodable_bitrate = list[5];
  if (!encodable_bitrate.IsNull()) {
    decoded.set_bitrate(std::get<int64_t>(encodable_bitrate));
  }
  auto& encodable_frame_rate = list[6];
  if (!encodable_frame_rate.IsNull()) {
    decoded.set_frame_rate(std::get<double>(encodable_frame_rate));
  }
  return decoded;
}

// MediaMetadataMessage

MediaMetadataMessage::MediaMetadataMessage() {}

MediaMetadataMessage::MediaMetadataMessage(
  const std::string* title,
  const std::string* artist,
  const std::string* album,
  const std::string* artwork_url,
  const int64_t* duration)
 : title_(title ? std::optional<std::string>(*title) : std::nullopt),
    artist_(artist ? std::optional<std::string>(*artist) : std::nullopt),
    album_(album ? std::optional<std::string>(*album) : std::nullopt),
    artwork_url_(artwork_url ? std::optional<std::string>(*artwork_url) : std::nullopt),
    duration_(duration ? std::optional<int64_t>(*duration) : std::nullopt) {}

const std::string* MediaMetadataMessage::title() const {
  return title_ ? &(*title_) : nullptr;
}

void MediaMetadataMessage::set_title(const std::string_view* value_arg) {
  title_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void MediaMetadataMessage::set_title(std::string_view value_arg) {
  title_ = value_arg;
}


const std::string* MediaMetadataMessage::artist() const {
  return artist_ ? &(*artist_) : nullptr;
}

void MediaMetadataMessage::set_artist(const std::string_view* value_arg) {
  artist_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void MediaMetadataMessage::set_artist(std::string_view value_arg) {
  artist_ = value_arg;
}


const std::string* MediaMetadataMessage::album() const {
  return album_ ? &(*album_) : nullptr;
}

void MediaMetadataMessage::set_album(const std::string_view* value_arg) {
  album_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void MediaMetadataMessage::set_album(std::string_view value_arg) {
  album_ = value_arg;
}


const std::string* MediaMetadataMessage::artwork_url() const {
  return artwork_url_ ? &(*artwork_url_) : nullptr;
}

void MediaMetadataMessage::set_artwork_url(const std::string_view* value_arg) {
  artwork_url_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void MediaMetadataMessage::set_artwork_url(std::string_view value_arg) {
  artwork_url_ = value_arg;
}


const int64_t* MediaMetadataMessage::duration() const {
  return duration_ ? &(*duration_) : nullptr;
}

void MediaMetadataMessage::set_duration(const int64_t* value_arg) {
  duration_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void MediaMetadataMessage::set_duration(int64_t value_arg) {
  duration_ = value_arg;
}


EncodableList MediaMetadataMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(title_ ? EncodableValue(*title_) : EncodableValue());
  list.push_back(artist_ ? EncodableValue(*artist_) : EncodableValue());
  list.push_back(album_ ? EncodableValue(*album_) : EncodableValue());
  list.push_back(artwork_url_ ? EncodableValue(*artwork_url_) : EncodableValue());
  list.push_back(duration_ ? EncodableValue(*duration_) : EncodableValue());
  return list;
}

MediaMetadataMessage MediaMetadataMessage::FromEncodableList(const EncodableList& list) {
  MediaMetadataMessage decoded;
  auto& encodable_title = list[0];
  if (!encodable_title.IsNull()) {
    decoded.set_title(std::get<std::string>(encodable_title));
  }
  auto& encodable_artist = list[1];
  if (!encodable_artist.IsNull()) {
    decoded.set_artist(std::get<std::string>(encodable_artist));
  }
  auto& encodable_album = list[2];
  if (!encodable_album.IsNull()) {
    decoded.set_album(std::get<std::string>(encodable_album));
  }
  auto& encodable_artwork_url = list[3];
  if (!encodable_artwork_url.IsNull()) {
    decoded.set_artwork_url(std::get<std::string>(encodable_artwork_url));
  }
  auto& encodable_duration = list[4];
  if (!encodable_duration.IsNull()) {
    decoded.set_duration(std::get<int64_t>(encodable_duration));
  }
  return decoded;
}

// SubtitleSourceMessage

SubtitleSourceMessage::SubtitleSourceMessage(
  const VideoSourceType& type,
  const std::string& path,
  bool is_default)
 : type_(type),
    path_(path),
    is_default_(is_default) {}

SubtitleSourceMessage::SubtitleSourceMessage(
  const VideoSourceType& type,
  const std::string& path,
  const SubtitleFormatEnum* format,
  const std::string* label,
  const std::string* language,
  bool is_default,
  const std::string* webvtt_content)
 : type_(type),
    path_(path),
    format_(format ? std::optional<SubtitleFormatEnum>(*format) : std::nullopt),
    label_(label ? std::optional<std::string>(*label) : std::nullopt),
    language_(language ? std::optional<std::string>(*language) : std::nullopt),
    is_default_(is_default),
    webvtt_content_(webvtt_content ? std::optional<std::string>(*webvtt_content) : std::nullopt) {}

const VideoSourceType& SubtitleSourceMessage::type() const {
  return type_;
}

void SubtitleSourceMessage::set_type(const VideoSourceType& value_arg) {
  type_ = value_arg;
}


const std::string& SubtitleSourceMessage::path() const {
  return path_;
}

void SubtitleSourceMessage::set_path(std::string_view value_arg) {
  path_ = value_arg;
}


const SubtitleFormatEnum* SubtitleSourceMessage::format() const {
  return format_ ? &(*format_) : nullptr;
}

void SubtitleSourceMessage::set_format(const SubtitleFormatEnum* value_arg) {
  format_ = value_arg ? std::optional<SubtitleFormatEnum>(*value_arg) : std::nullopt;
}

void SubtitleSourceMessage::set_format(const SubtitleFormatEnum& value_arg) {
  format_ = value_arg;
}


const std::string* SubtitleSourceMessage::label() const {
  return label_ ? &(*label_) : nullptr;
}

void SubtitleSourceMessage::set_label(const std::string_view* value_arg) {
  label_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void SubtitleSourceMessage::set_label(std::string_view value_arg) {
  label_ = value_arg;
}


const std::string* SubtitleSourceMessage::language() const {
  return language_ ? &(*language_) : nullptr;
}

void SubtitleSourceMessage::set_language(const std::string_view* value_arg) {
  language_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void SubtitleSourceMessage::set_language(std::string_view value_arg) {
  language_ = value_arg;
}


bool SubtitleSourceMessage::is_default() const {
  return is_default_;
}

void SubtitleSourceMessage::set_is_default(bool value_arg) {
  is_default_ = value_arg;
}


const std::string* SubtitleSourceMessage::webvtt_content() const {
  return webvtt_content_ ? &(*webvtt_content_) : nullptr;
}

void SubtitleSourceMessage::set_webvtt_content(const std::string_view* value_arg) {
  webvtt_content_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void SubtitleSourceMessage::set_webvtt_content(std::string_view value_arg) {
  webvtt_content_ = value_arg;
}


EncodableList SubtitleSourceMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(7);
  list.push_back(CustomEncodableValue(type_));
  list.push_back(EncodableValue(path_));
  list.push_back(format_ ? CustomEncodableValue(*format_) : EncodableValue());
  list.push_back(label_ ? EncodableValue(*label_) : EncodableValue());
  list.push_back(language_ ? EncodableValue(*language_) : EncodableValue());
  list.push_back(EncodableValue(is_default_));
  list.push_back(webvtt_content_ ? EncodableValue(*webvtt_content_) : EncodableValue());
  return list;
}

SubtitleSourceMessage SubtitleSourceMessage::FromEncodableList(const EncodableList& list) {
  SubtitleSourceMessage decoded(
    std::any_cast<const VideoSourceType&>(std::get<CustomEncodableValue>(list[0])),
    std::get<std::string>(list[1]),
    std::get<bool>(list[5]));
  auto& encodable_format = list[2];
  if (!encodable_format.IsNull()) {
    decoded.set_format(std::any_cast<const SubtitleFormatEnum&>(std::get<CustomEncodableValue>(encodable_format)));
  }
  auto& encodable_label = list[3];
  if (!encodable_label.IsNull()) {
    decoded.set_label(std::get<std::string>(encodable_label));
  }
  auto& encodable_language = list[4];
  if (!encodable_language.IsNull()) {
    decoded.set_language(std::get<std::string>(encodable_language));
  }
  auto& encodable_webvtt_content = list[6];
  if (!encodable_webvtt_content.IsNull()) {
    decoded.set_webvtt_content(std::get<std::string>(encodable_webvtt_content));
  }
  return decoded;
}

// ExternalSubtitleTrackMessage

ExternalSubtitleTrackMessage::ExternalSubtitleTrackMessage(
  const std::string& id,
  const std::string& label,
  bool is_default,
  const std::string& path,
  const std::string& source_type,
  const SubtitleFormatEnum& format)
 : id_(id),
    label_(label),
    is_default_(is_default),
    path_(path),
    source_type_(source_type),
    format_(format) {}

ExternalSubtitleTrackMessage::ExternalSubtitleTrackMessage(
  const std::string& id,
  const std::string& label,
  const std::string* language,
  bool is_default,
  const std::string& path,
  const std::string& source_type,
  const SubtitleFormatEnum& format)
 : id_(id),
    label_(label),
    language_(language ? std::optional<std::string>(*language) : std::nullopt),
    is_default_(is_default),
    path_(path),
    source_type_(source_type),
    format_(format) {}

const std::string& ExternalSubtitleTrackMessage::id() const {
  return id_;
}

void ExternalSubtitleTrackMessage::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const std::string& ExternalSubtitleTrackMessage::label() const {
  return label_;
}

void ExternalSubtitleTrackMessage::set_label(std::string_view value_arg) {
  label_ = value_arg;
}


const std::string* ExternalSubtitleTrackMessage::language() const {
  return language_ ? &(*language_) : nullptr;
}

void ExternalSubtitleTrackMessage::set_language(const std::string_view* value_arg) {
  language_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void ExternalSubtitleTrackMessage::set_language(std::string_view value_arg) {
  language_ = value_arg;
}


bool ExternalSubtitleTrackMessage::is_default() const {
  return is_default_;
}

void ExternalSubtitleTrackMessage::set_is_default(bool value_arg) {
  is_default_ = value_arg;
}


const std::string& ExternalSubtitleTrackMessage::path() const {
  return path_;
}

void ExternalSubtitleTrackMessage::set_path(std::string_view value_arg) {
  path_ = value_arg;
}


const std::string& ExternalSubtitleTrackMessage::source_type() const {
  return source_type_;
}

void ExternalSubtitleTrackMessage::set_source_type(std::string_view value_arg) {
  source_type_ = value_arg;
}


const SubtitleFormatEnum& ExternalSubtitleTrackMessage::format() const {
  return format_;
}

void ExternalSubtitleTrackMessage::set_format(const SubtitleFormatEnum& value_arg) {
  format_ = value_arg;
}


EncodableList ExternalSubtitleTrackMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(7);
  list.push_back(EncodableValue(id_));
  list.push_back(EncodableValue(label_));
  list.push_back(language_ ? EncodableValue(*language_) : EncodableValue());
  list.push_back(EncodableValue(is_default_));
  list.push_back(EncodableValue(path_));
  list.push_back(EncodableValue(source_type_));
  list.push_back(CustomEncodableValue(format_));
  return list;
}

ExternalSubtitleTrackMessage ExternalSubtitleTrackMessage::FromEncodableList(const EncodableList& list) {
  ExternalSubtitleTrackMessage decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    std::get<bool>(list[3]),
    std::get<std::string>(list[4]),
    std::get<std::string>(list[5]),
    std::any_cast<const SubtitleFormatEnum&>(std::get<CustomEncodableValue>(list[6])));
  auto& encodable_language = list[2];
  if (!encodable_language.IsNull()) {
    decoded.set_language(std::get<std::string>(encodable_language));
  }
  return decoded;
}

// VideoPlayerEventMessage

VideoPlayerEventMessage::VideoPlayerEventMessage(const std::string& type)
 : type_(type) {}

VideoPlayerEventMessage::VideoPlayerEventMessage(
  const std::string& type,
  const PlaybackStateEnum* state,
  const int64_t* position_ms,
  const int64_t* buffered_position_ms,
  const int64_t* duration_ms,
  const std::string* error_message,
  const std::string* error_code,
  const int64_t* width,
  const int64_t* height)
 : type_(type),
    state_(state ? std::optional<PlaybackStateEnum>(*state) : std::nullopt),
    position_ms_(position_ms ? std::optional<int64_t>(*position_ms) : std::nullopt),
    buffered_position_ms_(buffered_position_ms ? std::optional<int64_t>(*buffered_position_ms) : std::nullopt),
    duration_ms_(duration_ms ? std::optional<int64_t>(*duration_ms) : std::nullopt),
    error_message_(error_message ? std::optional<std::string>(*error_message) : std::nullopt),
    error_code_(error_code ? std::optional<std::string>(*error_code) : std::nullopt),
    width_(width ? std::optional<int64_t>(*width) : std::nullopt),
    height_(height ? std::optional<int64_t>(*height) : std::nullopt) {}

const std::string& VideoPlayerEventMessage::type() const {
  return type_;
}

void VideoPlayerEventMessage::set_type(std::string_view value_arg) {
  type_ = value_arg;
}


const PlaybackStateEnum* VideoPlayerEventMessage::state() const {
  return state_ ? &(*state_) : nullptr;
}

void VideoPlayerEventMessage::set_state(const PlaybackStateEnum* value_arg) {
  state_ = value_arg ? std::optional<PlaybackStateEnum>(*value_arg) : std::nullopt;
}

void VideoPlayerEventMessage::set_state(const PlaybackStateEnum& value_arg) {
  state_ = value_arg;
}


const int64_t* VideoPlayerEventMessage::position_ms() const {
  return position_ms_ ? &(*position_ms_) : nullptr;
}

void VideoPlayerEventMessage::set_position_ms(const int64_t* value_arg) {
  position_ms_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoPlayerEventMessage::set_position_ms(int64_t value_arg) {
  position_ms_ = value_arg;
}


const int64_t* VideoPlayerEventMessage::buffered_position_ms() const {
  return buffered_position_ms_ ? &(*buffered_position_ms_) : nullptr;
}

void VideoPlayerEventMessage::set_buffered_position_ms(const int64_t* value_arg) {
  buffered_position_ms_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoPlayerEventMessage::set_buffered_position_ms(int64_t value_arg) {
  buffered_position_ms_ = value_arg;
}


const int64_t* VideoPlayerEventMessage::duration_ms() const {
  return duration_ms_ ? &(*duration_ms_) : nullptr;
}

void VideoPlayerEventMessage::set_duration_ms(const int64_t* value_arg) {
  duration_ms_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoPlayerEventMessage::set_duration_ms(int64_t value_arg) {
  duration_ms_ = value_arg;
}


const std::string* VideoPlayerEventMessage::error_message() const {
  return error_message_ ? &(*error_message_) : nullptr;
}

void VideoPlayerEventMessage::set_error_message(const std::string_view* value_arg) {
  error_message_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoPlayerEventMessage::set_error_message(std::string_view value_arg) {
  error_message_ = value_arg;
}


const std::string* VideoPlayerEventMessage::error_code() const {
  return error_code_ ? &(*error_code_) : nullptr;
}

void VideoPlayerEventMessage::set_error_code(const std::string_view* value_arg) {
  error_code_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoPlayerEventMessage::set_error_code(std::string_view value_arg) {
  error_code_ = value_arg;
}


const int64_t* VideoPlayerEventMessage::width() const {
  return width_ ? &(*width_) : nullptr;
}

void VideoPlayerEventMessage::set_width(const int64_t* value_arg) {
  width_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoPlayerEventMessage::set_width(int64_t value_arg) {
  width_ = value_arg;
}


const int64_t* VideoPlayerEventMessage::height() const {
  return height_ ? &(*height_) : nullptr;
}

void VideoPlayerEventMessage::set_height(const int64_t* value_arg) {
  height_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void VideoPlayerEventMessage::set_height(int64_t value_arg) {
  height_ = value_arg;
}


EncodableList VideoPlayerEventMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(9);
  list.push_back(EncodableValue(type_));
  list.push_back(state_ ? CustomEncodableValue(*state_) : EncodableValue());
  list.push_back(position_ms_ ? EncodableValue(*position_ms_) : EncodableValue());
  list.push_back(buffered_position_ms_ ? EncodableValue(*buffered_position_ms_) : EncodableValue());
  list.push_back(duration_ms_ ? EncodableValue(*duration_ms_) : EncodableValue());
  list.push_back(error_message_ ? EncodableValue(*error_message_) : EncodableValue());
  list.push_back(error_code_ ? EncodableValue(*error_code_) : EncodableValue());
  list.push_back(width_ ? EncodableValue(*width_) : EncodableValue());
  list.push_back(height_ ? EncodableValue(*height_) : EncodableValue());
  return list;
}

VideoPlayerEventMessage VideoPlayerEventMessage::FromEncodableList(const EncodableList& list) {
  VideoPlayerEventMessage decoded(
    std::get<std::string>(list[0]));
  auto& encodable_state = list[1];
  if (!encodable_state.IsNull()) {
    decoded.set_state(std::any_cast<const PlaybackStateEnum&>(std::get<CustomEncodableValue>(encodable_state)));
  }
  auto& encodable_position_ms = list[2];
  if (!encodable_position_ms.IsNull()) {
    decoded.set_position_ms(std::get<int64_t>(encodable_position_ms));
  }
  auto& encodable_buffered_position_ms = list[3];
  if (!encodable_buffered_position_ms.IsNull()) {
    decoded.set_buffered_position_ms(std::get<int64_t>(encodable_buffered_position_ms));
  }
  auto& encodable_duration_ms = list[4];
  if (!encodable_duration_ms.IsNull()) {
    decoded.set_duration_ms(std::get<int64_t>(encodable_duration_ms));
  }
  auto& encodable_error_message = list[5];
  if (!encodable_error_message.IsNull()) {
    decoded.set_error_message(std::get<std::string>(encodable_error_message));
  }
  auto& encodable_error_code = list[6];
  if (!encodable_error_code.IsNull()) {
    decoded.set_error_code(std::get<std::string>(encodable_error_code));
  }
  auto& encodable_width = list[7];
  if (!encodable_width.IsNull()) {
    decoded.set_width(std::get<int64_t>(encodable_width));
  }
  auto& encodable_height = list[8];
  if (!encodable_height.IsNull()) {
    decoded.set_height(std::get<int64_t>(encodable_height));
  }
  return decoded;
}


PigeonInternalCodecSerializer::PigeonInternalCodecSerializer() {}

EncodableValue PigeonInternalCodecSerializer::ReadValueOfType(
  uint8_t type,
  flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 129: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<VideoSourceType>(enum_arg_value));
      }
    case 130: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<VideoScalingModeEnum>(enum_arg_value));
      }
    case 131: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<SubtitleRenderModeEnum>(enum_arg_value));
      }
    case 132: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<ControlsModeEnum>(enum_arg_value));
      }
    case 133: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<CastStateEnum>(enum_arg_value));
      }
    case 134: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<CastDeviceTypeEnum>(enum_arg_value));
      }
    case 135: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<PipActionTypeEnum>(enum_arg_value));
      }
    case 136: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<SubtitleFormatEnum>(enum_arg_value));
      }
    case 137: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<PlaybackStateEnum>(enum_arg_value));
      }
    case 138: {
        return CustomEncodableValue(VideoSourceMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 139: {
        return CustomEncodableValue(VideoPlayerOptionsMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 140: {
        return CustomEncodableValue(PlatformInfoMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 141: {
        return CustomEncodableValue(BatteryInfoMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 142: {
        return CustomEncodableValue(SubtitleTrackMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 143: {
        return CustomEncodableValue(AudioTrackMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 144: {
        return CustomEncodableValue(VideoQualityTrackMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 145: {
        return CustomEncodableValue(PipOptionsMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 146: {
        return CustomEncodableValue(PipActionMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 147: {
        return CustomEncodableValue(CastDeviceMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 148: {
        return CustomEncodableValue(VideoMetadataMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 149: {
        return CustomEncodableValue(MediaMetadataMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 150: {
        return CustomEncodableValue(SubtitleSourceMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 151: {
        return CustomEncodableValue(ExternalSubtitleTrackMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 152: {
        return CustomEncodableValue(VideoPlayerEventMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
    }
}

void PigeonInternalCodecSerializer::WriteValue(
  const EncodableValue& value,
  flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value = std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(VideoSourceType)) {
      stream->WriteByte(129);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<VideoSourceType>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(VideoScalingModeEnum)) {
      stream->WriteByte(130);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<VideoScalingModeEnum>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(SubtitleRenderModeEnum)) {
      stream->WriteByte(131);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<SubtitleRenderModeEnum>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(ControlsModeEnum)) {
      stream->WriteByte(132);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<ControlsModeEnum>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(CastStateEnum)) {
      stream->WriteByte(133);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<CastStateEnum>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(CastDeviceTypeEnum)) {
      stream->WriteByte(134);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<CastDeviceTypeEnum>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(PipActionTypeEnum)) {
      stream->WriteByte(135);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<PipActionTypeEnum>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(SubtitleFormatEnum)) {
      stream->WriteByte(136);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<SubtitleFormatEnum>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(PlaybackStateEnum)) {
      stream->WriteByte(137);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<PlaybackStateEnum>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(VideoSourceMessage)) {
      stream->WriteByte(138);
      WriteValue(EncodableValue(std::any_cast<VideoSourceMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(VideoPlayerOptionsMessage)) {
      stream->WriteByte(139);
      WriteValue(EncodableValue(std::any_cast<VideoPlayerOptionsMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(PlatformInfoMessage)) {
      stream->WriteByte(140);
      WriteValue(EncodableValue(std::any_cast<PlatformInfoMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(BatteryInfoMessage)) {
      stream->WriteByte(141);
      WriteValue(EncodableValue(std::any_cast<BatteryInfoMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(SubtitleTrackMessage)) {
      stream->WriteByte(142);
      WriteValue(EncodableValue(std::any_cast<SubtitleTrackMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(AudioTrackMessage)) {
      stream->WriteByte(143);
      WriteValue(EncodableValue(std::any_cast<AudioTrackMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(VideoQualityTrackMessage)) {
      stream->WriteByte(144);
      WriteValue(EncodableValue(std::any_cast<VideoQualityTrackMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(PipOptionsMessage)) {
      stream->WriteByte(145);
      WriteValue(EncodableValue(std::any_cast<PipOptionsMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(PipActionMessage)) {
      stream->WriteByte(146);
      WriteValue(EncodableValue(std::any_cast<PipActionMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(CastDeviceMessage)) {
      stream->WriteByte(147);
      WriteValue(EncodableValue(std::any_cast<CastDeviceMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(VideoMetadataMessage)) {
      stream->WriteByte(148);
      WriteValue(EncodableValue(std::any_cast<VideoMetadataMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(MediaMetadataMessage)) {
      stream->WriteByte(149);
      WriteValue(EncodableValue(std::any_cast<MediaMetadataMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(SubtitleSourceMessage)) {
      stream->WriteByte(150);
      WriteValue(EncodableValue(std::any_cast<SubtitleSourceMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(ExternalSubtitleTrackMessage)) {
      stream->WriteByte(151);
      WriteValue(EncodableValue(std::any_cast<ExternalSubtitleTrackMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(VideoPlayerEventMessage)) {
      stream->WriteByte(152);
      WriteValue(EncodableValue(std::any_cast<VideoPlayerEventMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by ProVideoPlayerHostApi.
const flutter::StandardMessageCodec& ProVideoPlayerHostApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&PigeonInternalCodecSerializer::GetInstance());
}

// Sets up an instance of `ProVideoPlayerHostApi` to handle messages through the `binary_messenger`.
void ProVideoPlayerHostApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  ProVideoPlayerHostApi* api) {
  ProVideoPlayerHostApi::SetUp(binary_messenger, api, "");
}

void ProVideoPlayerHostApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  ProVideoPlayerHostApi* api,
  const std::string& message_channel_suffix) {
  const std::string prepended_suffix = message_channel_suffix.length() > 0 ? std::string(".") + message_channel_suffix : "";
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.create" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_source_arg = args.at(0);
          if (encodable_source_arg.IsNull()) {
            reply(WrapError("source_arg unexpectedly null."));
            return;
          }
          const auto& source_arg = std::any_cast<const VideoSourceMessage&>(std::get<CustomEncodableValue>(encodable_source_arg));
          const auto& encodable_options_arg = args.at(1);
          if (encodable_options_arg.IsNull()) {
            reply(WrapError("options_arg unexpectedly null."));
            return;
          }
          const auto& options_arg = std::any_cast<const VideoPlayerOptionsMessage&>(std::get<CustomEncodableValue>(encodable_options_arg));
          api->Create(source_arg, options_arg, [reply](ErrorOr<int64_t>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.dispose" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->Dispose(player_id_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.play" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->Play(player_id_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.pause" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->Pause(player_id_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.stop" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->Stop(player_id_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.seekTo" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_position_ms_arg = args.at(1);
          if (encodable_position_ms_arg.IsNull()) {
            reply(WrapError("position_ms_arg unexpectedly null."));
            return;
          }
          const int64_t position_ms_arg = encodable_position_ms_arg.LongValue();
          api->SeekTo(player_id_arg, position_ms_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setPlaybackSpeed" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_speed_arg = args.at(1);
          if (encodable_speed_arg.IsNull()) {
            reply(WrapError("speed_arg unexpectedly null."));
            return;
          }
          const auto& speed_arg = std::get<double>(encodable_speed_arg);
          api->SetPlaybackSpeed(player_id_arg, speed_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setVolume" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_volume_arg = args.at(1);
          if (encodable_volume_arg.IsNull()) {
            reply(WrapError("volume_arg unexpectedly null."));
            return;
          }
          const auto& volume_arg = std::get<double>(encodable_volume_arg);
          api->SetVolume(player_id_arg, volume_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getPosition" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->GetPosition(player_id_arg, [reply](ErrorOr<int64_t>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getDuration" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->GetDuration(player_id_arg, [reply](ErrorOr<int64_t>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getPlatformInfo" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->GetPlatformInfo([reply](ErrorOr<PlatformInfoMessage>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setVerboseLogging" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_enabled_arg = args.at(0);
          if (encodable_enabled_arg.IsNull()) {
            reply(WrapError("enabled_arg unexpectedly null."));
            return;
          }
          const auto& enabled_arg = std::get<bool>(encodable_enabled_arg);
          api->SetVerboseLogging(enabled_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsPictureInPicture" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsPictureInPicture([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsFullscreen" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsFullscreen([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsBackgroundPlayback" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsBackgroundPlayback([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsCasting" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsCasting([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsAirPlay" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsAirPlay([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsChromecast" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsChromecast([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsRemotePlayback" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsRemotePlayback([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsQualitySelection" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsQualitySelection([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsPlaybackSpeedControl" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsPlaybackSpeedControl([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsSubtitles" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsSubtitles([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsExternalSubtitles" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsExternalSubtitles([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsAudioTrackSelection" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsAudioTrackSelection([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsChapters" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsChapters([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsVideoMetadataExtraction" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsVideoMetadataExtraction([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsNetworkMonitoring" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsNetworkMonitoring([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsBandwidthEstimation" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsBandwidthEstimation([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsAdaptiveBitrate" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsAdaptiveBitrate([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsHLS" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsHLS([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsDASH" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsDASH([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsDeviceVolumeControl" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsDeviceVolumeControl([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsScreenBrightnessControl" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->SupportsScreenBrightnessControl([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getDeviceVolume" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->GetDeviceVolume([reply](ErrorOr<double>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setDeviceVolume" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_volume_arg = args.at(0);
          if (encodable_volume_arg.IsNull()) {
            reply(WrapError("volume_arg unexpectedly null."));
            return;
          }
          const auto& volume_arg = std::get<double>(encodable_volume_arg);
          api->SetDeviceVolume(volume_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getScreenBrightness" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->GetScreenBrightness([reply](ErrorOr<double>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setScreenBrightness" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_brightness_arg = args.at(0);
          if (encodable_brightness_arg.IsNull()) {
            reply(WrapError("brightness_arg unexpectedly null."));
            return;
          }
          const auto& brightness_arg = std::get<double>(encodable_brightness_arg);
          api->SetScreenBrightness(brightness_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getBatteryInfo" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->GetBatteryInfo([reply](ErrorOr<std::optional<BatteryInfoMessage>>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            auto output_optional = std::move(output).TakeValue();
            if (output_optional) {
              wrapped.push_back(CustomEncodableValue(std::move(output_optional).value()));
            } else {
              wrapped.push_back(EncodableValue());
            }
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setLooping" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_looping_arg = args.at(1);
          if (encodable_looping_arg.IsNull()) {
            reply(WrapError("looping_arg unexpectedly null."));
            return;
          }
          const auto& looping_arg = std::get<bool>(encodable_looping_arg);
          api->SetLooping(player_id_arg, looping_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setScalingMode" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_mode_arg = args.at(1);
          if (encodable_mode_arg.IsNull()) {
            reply(WrapError("mode_arg unexpectedly null."));
            return;
          }
          const auto& mode_arg = std::any_cast<const VideoScalingModeEnum&>(std::get<CustomEncodableValue>(encodable_mode_arg));
          api->SetScalingMode(player_id_arg, mode_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setControlsMode" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_mode_arg = args.at(1);
          if (encodable_mode_arg.IsNull()) {
            reply(WrapError("mode_arg unexpectedly null."));
            return;
          }
          const auto& mode_arg = std::any_cast<const ControlsModeEnum&>(std::get<CustomEncodableValue>(encodable_mode_arg));
          api->SetControlsMode(player_id_arg, mode_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setSubtitleTrack" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_track_arg = args.at(1);
          const auto* track_arg = encodable_track_arg.IsNull() ? nullptr : &(std::any_cast<const SubtitleTrackMessage&>(std::get<CustomEncodableValue>(encodable_track_arg)));
          api->SetSubtitleTrack(player_id_arg, track_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setSubtitleRenderMode" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_mode_arg = args.at(1);
          if (encodable_mode_arg.IsNull()) {
            reply(WrapError("mode_arg unexpectedly null."));
            return;
          }
          const auto& mode_arg = std::any_cast<const SubtitleRenderModeEnum&>(std::get<CustomEncodableValue>(encodable_mode_arg));
          api->SetSubtitleRenderMode(player_id_arg, mode_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.addExternalSubtitle" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_source_arg = args.at(1);
          if (encodable_source_arg.IsNull()) {
            reply(WrapError("source_arg unexpectedly null."));
            return;
          }
          const auto& source_arg = std::any_cast<const SubtitleSourceMessage&>(std::get<CustomEncodableValue>(encodable_source_arg));
          api->AddExternalSubtitle(player_id_arg, source_arg, [reply](ErrorOr<std::optional<ExternalSubtitleTrackMessage>>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            auto output_optional = std::move(output).TakeValue();
            if (output_optional) {
              wrapped.push_back(CustomEncodableValue(std::move(output_optional).value()));
            } else {
              wrapped.push_back(EncodableValue());
            }
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.removeExternalSubtitle" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_track_id_arg = args.at(1);
          if (encodable_track_id_arg.IsNull()) {
            reply(WrapError("track_id_arg unexpectedly null."));
            return;
          }
          const auto& track_id_arg = std::get<std::string>(encodable_track_id_arg);
          api->RemoveExternalSubtitle(player_id_arg, track_id_arg, [reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getExternalSubtitles" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->GetExternalSubtitles(player_id_arg, [reply](ErrorOr<EncodableList>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setAudioTrack" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_track_arg = args.at(1);
          const auto* track_arg = encodable_track_arg.IsNull() ? nullptr : &(std::any_cast<const AudioTrackMessage&>(std::get<CustomEncodableValue>(encodable_track_arg)));
          api->SetAudioTrack(player_id_arg, track_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.enterPip" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_options_arg = args.at(1);
          if (encodable_options_arg.IsNull()) {
            reply(WrapError("options_arg unexpectedly null."));
            return;
          }
          const auto& options_arg = std::any_cast<const PipOptionsMessage&>(std::get<CustomEncodableValue>(encodable_options_arg));
          api->EnterPip(player_id_arg, options_arg, [reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.exitPip" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->ExitPip(player_id_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.isPipSupported" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->IsPipSupported([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setPipActions" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_actions_arg = args.at(1);
          if (encodable_actions_arg.IsNull()) {
            reply(WrapError("actions_arg unexpectedly null."));
            return;
          }
          const auto& actions_arg = std::get<EncodableList>(encodable_actions_arg);
          api->SetPipActions(player_id_arg, actions_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.enterFullscreen" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->EnterFullscreen(player_id_arg, [reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.exitFullscreen" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->ExitFullscreen(player_id_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setWindowFullscreen" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_fullscreen_arg = args.at(0);
          if (encodable_fullscreen_arg.IsNull()) {
            reply(WrapError("fullscreen_arg unexpectedly null."));
            return;
          }
          const auto& fullscreen_arg = std::get<bool>(encodable_fullscreen_arg);
          api->SetWindowFullscreen(fullscreen_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setBackgroundPlayback" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_enabled_arg = args.at(1);
          if (encodable_enabled_arg.IsNull()) {
            reply(WrapError("enabled_arg unexpectedly null."));
            return;
          }
          const auto& enabled_arg = std::get<bool>(encodable_enabled_arg);
          api->SetBackgroundPlayback(player_id_arg, enabled_arg, [reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.isBackgroundPlaybackSupported" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->IsBackgroundPlaybackSupported([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getVideoQualities" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->GetVideoQualities(player_id_arg, [reply](ErrorOr<EncodableList>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setVideoQuality" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_track_arg = args.at(1);
          if (encodable_track_arg.IsNull()) {
            reply(WrapError("track_arg unexpectedly null."));
            return;
          }
          const auto& track_arg = std::any_cast<const VideoQualityTrackMessage&>(std::get<CustomEncodableValue>(encodable_track_arg));
          api->SetVideoQuality(player_id_arg, track_arg, [reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getCurrentVideoQuality" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->GetCurrentVideoQuality(player_id_arg, [reply](ErrorOr<VideoQualityTrackMessage>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.isQualitySelectionSupported" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->IsQualitySelectionSupported(player_id_arg, [reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getVideoMetadata" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->GetVideoMetadata(player_id_arg, [reply](ErrorOr<std::optional<VideoMetadataMessage>>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            auto output_optional = std::move(output).TakeValue();
            if (output_optional) {
              wrapped.push_back(CustomEncodableValue(std::move(output_optional).value()));
            } else {
              wrapped.push_back(EncodableValue());
            }
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setMediaMetadata" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_metadata_arg = args.at(1);
          if (encodable_metadata_arg.IsNull()) {
            reply(WrapError("metadata_arg unexpectedly null."));
            return;
          }
          const auto& metadata_arg = std::any_cast<const MediaMetadataMessage&>(std::get<CustomEncodableValue>(encodable_metadata_arg));
          api->SetMediaMetadata(player_id_arg, metadata_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.isCastingSupported" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->IsCastingSupported([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getAvailableCastDevices" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->GetAvailableCastDevices(player_id_arg, [reply](ErrorOr<EncodableList>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.startCasting" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_device_arg = args.at(1);
          const auto* device_arg = encodable_device_arg.IsNull() ? nullptr : &(std::any_cast<const CastDeviceMessage&>(std::get<CustomEncodableValue>(encodable_device_arg)));
          api->StartCasting(player_id_arg, device_arg, [reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.stopCasting" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->StopCasting(player_id_arg, [reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getCastState" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->GetCastState(player_id_arg, [reply](ErrorOr<CastStateEnum>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getCurrentCastDevice" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->GetCurrentCastDevice(player_id_arg, [reply](ErrorOr<std::optional<CastDeviceMessage>>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            auto output_optional = std::move(output).TakeValue();
            if (output_optional) {
              wrapped.push_back(CustomEncodableValue(std::move(output_optional).value()));
            } else {
              wrapped.push_back(EncodableValue());
            }
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue ProVideoPlayerHostApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue ProVideoPlayerHostApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}

// Generated class from Pigeon that represents Flutter messages that can be called from C++.
ProVideoPlayerFlutterApi::ProVideoPlayerFlutterApi(flutter::BinaryMessenger* binary_messenger)
 : binary_messenger_(binary_messenger),
    message_channel_suffix_("") {}

ProVideoPlayerFlutterApi::ProVideoPlayerFlutterApi(
  flutter::BinaryMessenger* binary_messenger,
  const std::string& message_channel_suffix)
 : binary_messenger_(binary_messenger),
    message_channel_suffix_(message_channel_suffix.length() > 0 ? std::string(".") + message_channel_suffix : "") {}

const flutter::StandardMessageCodec& ProVideoPlayerFlutterApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&PigeonInternalCodecSerializer::GetInstance());
}

void ProVideoPlayerFlutterApi::OnEvent(
  int64_t player_id_arg,
  const VideoPlayerEventMessage& event_arg,
  std::function<void(void)>&& on_success,
  std::function<void(const FlutterError&)>&& on_error) {
  const std::string channel_name = "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerFlutterApi.onEvent" + message_channel_suffix_;
  BasicMessageChannel<> channel(binary_messenger_, channel_name, &GetCodec());
  EncodableValue encoded_api_arguments = EncodableValue(EncodableList{
    EncodableValue(player_id_arg),
    CustomEncodableValue(event_arg),
  });
  channel.Send(encoded_api_arguments, [channel_name, on_success = std::move(on_success), on_error = std::move(on_error)](const uint8_t* reply, size_t reply_size) {
    std::unique_ptr<EncodableValue> response = GetCodec().DecodeMessage(reply, reply_size);
    const auto& encodable_return_value = *response;
    const auto* list_return_value = std::get_if<EncodableList>(&encodable_return_value);
    if (list_return_value) {
      if (list_return_value->size() > 1) {
        on_error(FlutterError(std::get<std::string>(list_return_value->at(0)), std::get<std::string>(list_return_value->at(1)), list_return_value->at(2)));
      } else {
        on_success();
      }
    } else {
      on_error(CreateConnectionError(channel_name));
    } 
  });
}

}  // namespace pro_video_player
