// Copyright 2025 The Pro Video Player Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.7.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PigeonError {
  return PigeonError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Video source types supported by the platform.
enum VideoSourceType: Int {
  /// Network video source (HTTP/HTTPS URL).
  case network = 0
  /// Local file video source.
  case file = 1
  /// Asset video source (bundled with the app).
  case asset = 2
}

/// Video scaling modes.
enum VideoScalingModeEnum: Int {
  /// Fit the video within the view (letterbox/pillarbox).
  case fit = 0
  /// Fill the entire view (may crop video).
  case fill = 1
  /// Stretch the video to fill the view.
  case stretch = 2
}

/// Subtitle render modes.
enum SubtitleRenderModeEnum: Int {
  /// Auto-select best render mode.
  case auto = 0
  /// Render subtitles natively.
  case native = 1
  /// Render subtitles in Flutter.
  case flutter = 2
}

/// Controls mode.
enum ControlsModeEnum: Int {
  /// Video only, no controls.
  case videoOnly = 0
  /// Native platform controls.
  case nativeControls = 1
  /// Flutter controls.
  case flutterControls = 2
  /// Custom controls.
  case customControls = 3
}

/// Cast state.
enum CastStateEnum: Int {
  /// Not connected to any cast device.
  case notConnected = 0
  /// Connecting to cast device.
  case connecting = 1
  /// Connected to cast device.
  case connected = 2
  /// Disconnecting from cast device.
  case disconnecting = 3
}

/// Cast device type.
enum CastDeviceTypeEnum: Int {
  /// AirPlay device.
  case airPlay = 0
  /// Chromecast device.
  case chromecast = 1
  /// Web Remote Playback device.
  case webRemotePlayback = 2
  /// Unknown device type.
  case unknown = 3
}

/// PiP action type.
enum PipActionTypeEnum: Int {
  /// Play/pause toggle.
  case playPause = 0
  /// Skip to previous.
  case skipPrevious = 1
  /// Skip to next.
  case skipNext = 2
  /// Skip backward.
  case skipBackward = 3
  /// Skip forward.
  case skipForward = 4
}

/// Subtitle format.
enum SubtitleFormatEnum: Int {
  /// SRT format.
  case srt = 0
  /// WebVTT format.
  case vtt = 1
  /// SSA format.
  case ssa = 2
  /// ASS format.
  case ass = 3
  /// TTML format.
  case ttml = 4
}

/// Playback state enumeration.
enum PlaybackStateEnum: Int {
  /// Player is uninitialized.
  case uninitialized = 0
  /// Player is initializing.
  case initializing = 1
  /// Player is ready to play.
  case ready = 2
  /// Player is playing.
  case playing = 3
  /// Player is paused.
  case paused = 4
  /// Playback has completed.
  case completed = 5
  /// Player is buffering.
  case buffering = 6
  /// Player encountered an error.
  case error = 7
  /// Player has been disposed.
  case disposed = 8
}

/// Video source data passed to the platform.
///
/// This represents the video source to be played. Only one of [url], [path],
/// or [assetPath] should be set based on the [type].
///
/// Generated class from Pigeon that represents data sent in messages.
struct VideoSourceMessage {
  /// The type of video source.
  var type: VideoSourceType
  /// Network URL (for network sources).
  var url: String? = nil
  /// File path (for file sources).
  var path: String? = nil
  /// Asset path (for asset sources).
  var assetPath: String? = nil
  /// HTTP headers (for network sources).
  var headers: [String?: String?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> VideoSourceMessage? {
    let type = pigeonVar_list[0] as! VideoSourceType
    let url: String? = nilOrValue(pigeonVar_list[1])
    let path: String? = nilOrValue(pigeonVar_list[2])
    let assetPath: String? = nilOrValue(pigeonVar_list[3])
    let headers: [String?: String?]? = nilOrValue(pigeonVar_list[4])

    return VideoSourceMessage(
      type: type,
      url: url,
      path: path,
      assetPath: assetPath,
      headers: headers
    )
  }
  func toList() -> [Any?] {
    return [
      type,
      url,
      path,
      assetPath,
      headers,
    ]
  }
}

/// Video player options for initialization.
///
/// Generated class from Pigeon that represents data sent in messages.
struct VideoPlayerOptionsMessage {
  /// Whether to start playing automatically after initialization.
  var autoPlay: Bool
  /// Whether to loop the video.
  var looping: Bool
  /// Initial volume (0.0 to 1.0).
  var volume: Double
  /// Initial playback speed.
  var playbackSpeed: Double
  /// Start position in milliseconds.
  var startPosition: Int64? = nil
  /// Whether to enable Picture-in-Picture mode.
  var enablePip: Bool? = nil
  /// Whether to enable background playback.
  var enableBackgroundPlayback: Bool? = nil
  /// Preferred audio language code.
  var preferredAudioLanguage: String? = nil
  /// Preferred subtitle language code.
  var preferredSubtitleLanguage: String? = nil
  /// Maximum bitrate in bits per second.
  var maxBitrate: Int64? = nil
  /// Minimum bitrate in bits per second.
  var minBitrate: Int64? = nil
  /// Preferred audio rendition name.
  var preferredAudioRendition: String? = nil
  /// Whether to allow background playback (deprecated, use enableBackgroundPlayback).
  var allowBackgroundPlayback: Bool
  /// Whether to mix audio with other apps.
  var mixWithOthers: Bool
  /// Whether to allow Picture-in-Picture mode (deprecated, use enablePip).
  var allowPip: Bool
  /// Whether to auto-enter PiP when app goes to background.
  var autoEnterPipOnBackground: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> VideoPlayerOptionsMessage? {
    let autoPlay = pigeonVar_list[0] as! Bool
    let looping = pigeonVar_list[1] as! Bool
    let volume = pigeonVar_list[2] as! Double
    let playbackSpeed = pigeonVar_list[3] as! Double
    let startPosition: Int64? = nilOrValue(pigeonVar_list[4])
    let enablePip: Bool? = nilOrValue(pigeonVar_list[5])
    let enableBackgroundPlayback: Bool? = nilOrValue(pigeonVar_list[6])
    let preferredAudioLanguage: String? = nilOrValue(pigeonVar_list[7])
    let preferredSubtitleLanguage: String? = nilOrValue(pigeonVar_list[8])
    let maxBitrate: Int64? = nilOrValue(pigeonVar_list[9])
    let minBitrate: Int64? = nilOrValue(pigeonVar_list[10])
    let preferredAudioRendition: String? = nilOrValue(pigeonVar_list[11])
    let allowBackgroundPlayback = pigeonVar_list[12] as! Bool
    let mixWithOthers = pigeonVar_list[13] as! Bool
    let allowPip = pigeonVar_list[14] as! Bool
    let autoEnterPipOnBackground = pigeonVar_list[15] as! Bool

    return VideoPlayerOptionsMessage(
      autoPlay: autoPlay,
      looping: looping,
      volume: volume,
      playbackSpeed: playbackSpeed,
      startPosition: startPosition,
      enablePip: enablePip,
      enableBackgroundPlayback: enableBackgroundPlayback,
      preferredAudioLanguage: preferredAudioLanguage,
      preferredSubtitleLanguage: preferredSubtitleLanguage,
      maxBitrate: maxBitrate,
      minBitrate: minBitrate,
      preferredAudioRendition: preferredAudioRendition,
      allowBackgroundPlayback: allowBackgroundPlayback,
      mixWithOthers: mixWithOthers,
      allowPip: allowPip,
      autoEnterPipOnBackground: autoEnterPipOnBackground
    )
  }
  func toList() -> [Any?] {
    return [
      autoPlay,
      looping,
      volume,
      playbackSpeed,
      startPosition,
      enablePip,
      enableBackgroundPlayback,
      preferredAudioLanguage,
      preferredSubtitleLanguage,
      maxBitrate,
      minBitrate,
      preferredAudioRendition,
      allowBackgroundPlayback,
      mixWithOthers,
      allowPip,
      autoEnterPipOnBackground,
    ]
  }
}

/// Platform information returned by the platform.
///
/// Contains static platform metadata that doesn't require async checks.
///
/// Generated class from Pigeon that represents data sent in messages.
struct PlatformInfoMessage {
  /// Platform name (e.g., "iOS", "Android", "Web").
  var platformName: String
  /// Native player type (e.g., "AVPlayer", "ExoPlayer", "HTML5").
  var nativePlayerType: String
  /// Additional platform-specific information as key-value pairs.
  ///
  /// May include:
  /// - OS version
  /// - SDK version
  /// - Browser user agent
  /// - Hardware capabilities
  var additionalInfo: [String?: Any?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PlatformInfoMessage? {
    let platformName = pigeonVar_list[0] as! String
    let nativePlayerType = pigeonVar_list[1] as! String
    let additionalInfo: [String?: Any?]? = nilOrValue(pigeonVar_list[2])

    return PlatformInfoMessage(
      platformName: platformName,
      nativePlayerType: nativePlayerType,
      additionalInfo: additionalInfo
    )
  }
  func toList() -> [Any?] {
    return [
      platformName,
      nativePlayerType,
      additionalInfo,
    ]
  }
}

/// Battery information.
///
/// Generated class from Pigeon that represents data sent in messages.
struct BatteryInfoMessage {
  /// Battery percentage (0-100).
  var percentage: Int64
  /// Whether the device is charging.
  var isCharging: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> BatteryInfoMessage? {
    let percentage = pigeonVar_list[0] as! Int64
    let isCharging = pigeonVar_list[1] as! Bool

    return BatteryInfoMessage(
      percentage: percentage,
      isCharging: isCharging
    )
  }
  func toList() -> [Any?] {
    return [
      percentage,
      isCharging,
    ]
  }
}

/// Subtitle track information.
///
/// Generated class from Pigeon that represents data sent in messages.
struct SubtitleTrackMessage {
  /// Track ID.
  var id: String
  /// Track label.
  var label: String? = nil
  /// Track language code.
  var language: String? = nil
  /// Subtitle format.
  var format: SubtitleFormatEnum? = nil
  /// Whether this is the default track.
  var isDefault: Bool? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> SubtitleTrackMessage? {
    let id = pigeonVar_list[0] as! String
    let label: String? = nilOrValue(pigeonVar_list[1])
    let language: String? = nilOrValue(pigeonVar_list[2])
    let format: SubtitleFormatEnum? = nilOrValue(pigeonVar_list[3])
    let isDefault: Bool? = nilOrValue(pigeonVar_list[4])

    return SubtitleTrackMessage(
      id: id,
      label: label,
      language: language,
      format: format,
      isDefault: isDefault
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      label,
      language,
      format,
      isDefault,
    ]
  }
}

/// Audio track information.
///
/// Generated class from Pigeon that represents data sent in messages.
struct AudioTrackMessage {
  /// Track ID.
  var id: String
  /// Track label.
  var label: String? = nil
  /// Track language code.
  var language: String? = nil
  /// Number of audio channels.
  var channelCount: Int64? = nil
  /// Whether this is the default track.
  var isDefault: Bool? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> AudioTrackMessage? {
    let id = pigeonVar_list[0] as! String
    let label: String? = nilOrValue(pigeonVar_list[1])
    let language: String? = nilOrValue(pigeonVar_list[2])
    let channelCount: Int64? = nilOrValue(pigeonVar_list[3])
    let isDefault: Bool? = nilOrValue(pigeonVar_list[4])

    return AudioTrackMessage(
      id: id,
      label: label,
      language: language,
      channelCount: channelCount,
      isDefault: isDefault
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      label,
      language,
      channelCount,
      isDefault,
    ]
  }
}

/// Video quality track information.
///
/// Generated class from Pigeon that represents data sent in messages.
struct VideoQualityTrackMessage {
  /// Track ID.
  var id: String
  /// Track label.
  var label: String? = nil
  /// Bitrate in bits per second.
  var bitrate: Int64? = nil
  /// Video width in pixels.
  var width: Int64? = nil
  /// Video height in pixels.
  var height: Int64? = nil
  /// Video codec.
  var codec: String? = nil
  /// Whether this is the default track.
  var isDefault: Bool? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> VideoQualityTrackMessage? {
    let id = pigeonVar_list[0] as! String
    let label: String? = nilOrValue(pigeonVar_list[1])
    let bitrate: Int64? = nilOrValue(pigeonVar_list[2])
    let width: Int64? = nilOrValue(pigeonVar_list[3])
    let height: Int64? = nilOrValue(pigeonVar_list[4])
    let codec: String? = nilOrValue(pigeonVar_list[5])
    let isDefault: Bool? = nilOrValue(pigeonVar_list[6])

    return VideoQualityTrackMessage(
      id: id,
      label: label,
      bitrate: bitrate,
      width: width,
      height: height,
      codec: codec,
      isDefault: isDefault
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      label,
      bitrate,
      width,
      height,
      codec,
      isDefault,
    ]
  }
}

/// Picture-in-picture options.
///
/// Generated class from Pigeon that represents data sent in messages.
struct PipOptionsMessage {
  /// Aspect ratio (width / height).
  var aspectRatio: Double? = nil
  /// Auto-enter PiP when app goes to background.
  var autoEnterOnBackground: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PipOptionsMessage? {
    let aspectRatio: Double? = nilOrValue(pigeonVar_list[0])
    let autoEnterOnBackground = pigeonVar_list[1] as! Bool

    return PipOptionsMessage(
      aspectRatio: aspectRatio,
      autoEnterOnBackground: autoEnterOnBackground
    )
  }
  func toList() -> [Any?] {
    return [
      aspectRatio,
      autoEnterOnBackground,
    ]
  }
}

/// Picture-in-picture action.
///
/// Generated class from Pigeon that represents data sent in messages.
struct PipActionMessage {
  /// Action type.
  var type: PipActionTypeEnum
  /// Action title.
  var title: String? = nil
  /// Icon name.
  var iconName: String? = nil
  /// Optional skip interval in milliseconds.
  var skipIntervalMs: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PipActionMessage? {
    let type = pigeonVar_list[0] as! PipActionTypeEnum
    let title: String? = nilOrValue(pigeonVar_list[1])
    let iconName: String? = nilOrValue(pigeonVar_list[2])
    let skipIntervalMs: Int64? = nilOrValue(pigeonVar_list[3])

    return PipActionMessage(
      type: type,
      title: title,
      iconName: iconName,
      skipIntervalMs: skipIntervalMs
    )
  }
  func toList() -> [Any?] {
    return [
      type,
      title,
      iconName,
      skipIntervalMs,
    ]
  }
}

/// Cast device information.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CastDeviceMessage {
  /// Device ID.
  var id: String
  /// Device name.
  var name: String
  /// Device type.
  var type: CastDeviceTypeEnum


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CastDeviceMessage? {
    let id = pigeonVar_list[0] as! String
    let name = pigeonVar_list[1] as! String
    let type = pigeonVar_list[2] as! CastDeviceTypeEnum

    return CastDeviceMessage(
      id: id,
      name: name,
      type: type
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      name,
      type,
    ]
  }
}

/// Video metadata.
///
/// Generated class from Pigeon that represents data sent in messages.
struct VideoMetadataMessage {
  /// Duration in milliseconds.
  var duration: Int64? = nil
  /// Video width in pixels.
  var width: Int64? = nil
  /// Video height in pixels.
  var height: Int64? = nil
  /// Video codec.
  var videoCodec: String? = nil
  /// Audio codec.
  var audioCodec: String? = nil
  /// Bitrate in bits per second.
  var bitrate: Int64? = nil
  /// Frame rate.
  var frameRate: Double? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> VideoMetadataMessage? {
    let duration: Int64? = nilOrValue(pigeonVar_list[0])
    let width: Int64? = nilOrValue(pigeonVar_list[1])
    let height: Int64? = nilOrValue(pigeonVar_list[2])
    let videoCodec: String? = nilOrValue(pigeonVar_list[3])
    let audioCodec: String? = nilOrValue(pigeonVar_list[4])
    let bitrate: Int64? = nilOrValue(pigeonVar_list[5])
    let frameRate: Double? = nilOrValue(pigeonVar_list[6])

    return VideoMetadataMessage(
      duration: duration,
      width: width,
      height: height,
      videoCodec: videoCodec,
      audioCodec: audioCodec,
      bitrate: bitrate,
      frameRate: frameRate
    )
  }
  func toList() -> [Any?] {
    return [
      duration,
      width,
      height,
      videoCodec,
      audioCodec,
      bitrate,
      frameRate,
    ]
  }
}

/// Media metadata for platform controls.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MediaMetadataMessage {
  /// Media title.
  var title: String? = nil
  /// Media artist/author.
  var artist: String? = nil
  /// Album name.
  var album: String? = nil
  /// Artwork URL.
  var artworkUrl: String? = nil
  /// Duration in milliseconds.
  var duration: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MediaMetadataMessage? {
    let title: String? = nilOrValue(pigeonVar_list[0])
    let artist: String? = nilOrValue(pigeonVar_list[1])
    let album: String? = nilOrValue(pigeonVar_list[2])
    let artworkUrl: String? = nilOrValue(pigeonVar_list[3])
    let duration: Int64? = nilOrValue(pigeonVar_list[4])

    return MediaMetadataMessage(
      title: title,
      artist: artist,
      album: album,
      artworkUrl: artworkUrl,
      duration: duration
    )
  }
  func toList() -> [Any?] {
    return [
      title,
      artist,
      album,
      artworkUrl,
      duration,
    ]
  }
}

/// Subtitle source information.
///
/// Generated class from Pigeon that represents data sent in messages.
struct SubtitleSourceMessage {
  /// Source type (network, file, asset).
  var type: VideoSourceType
  /// Path or URL.
  var path: String
  /// Subtitle format.
  var format: SubtitleFormatEnum? = nil
  /// Track label.
  var label: String? = nil
  /// Language code.
  var language: String? = nil
  /// Whether this is the default subtitle.
  var isDefault: Bool
  /// WebVTT content (for in-memory subtitles).
  var webvttContent: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> SubtitleSourceMessage? {
    let type = pigeonVar_list[0] as! VideoSourceType
    let path = pigeonVar_list[1] as! String
    let format: SubtitleFormatEnum? = nilOrValue(pigeonVar_list[2])
    let label: String? = nilOrValue(pigeonVar_list[3])
    let language: String? = nilOrValue(pigeonVar_list[4])
    let isDefault = pigeonVar_list[5] as! Bool
    let webvttContent: String? = nilOrValue(pigeonVar_list[6])

    return SubtitleSourceMessage(
      type: type,
      path: path,
      format: format,
      label: label,
      language: language,
      isDefault: isDefault,
      webvttContent: webvttContent
    )
  }
  func toList() -> [Any?] {
    return [
      type,
      path,
      format,
      label,
      language,
      isDefault,
      webvttContent,
    ]
  }
}

/// External subtitle track information.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ExternalSubtitleTrackMessage {
  /// Track ID.
  var id: String
  /// Track label.
  var label: String
  /// Track language code.
  var language: String? = nil
  /// Whether this is the default track.
  var isDefault: Bool
  /// Source path or URL.
  var path: String
  /// Source type.
  var sourceType: String
  /// Subtitle format.
  var format: SubtitleFormatEnum


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ExternalSubtitleTrackMessage? {
    let id = pigeonVar_list[0] as! String
    let label = pigeonVar_list[1] as! String
    let language: String? = nilOrValue(pigeonVar_list[2])
    let isDefault = pigeonVar_list[3] as! Bool
    let path = pigeonVar_list[4] as! String
    let sourceType = pigeonVar_list[5] as! String
    let format = pigeonVar_list[6] as! SubtitleFormatEnum

    return ExternalSubtitleTrackMessage(
      id: id,
      label: label,
      language: language,
      isDefault: isDefault,
      path: path,
      sourceType: sourceType,
      format: format
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      label,
      language,
      isDefault,
      path,
      sourceType,
      format,
    ]
  }
}

/// Video player event data sent from the platform to Dart.
///
/// This is a base class for all events. Specific event types will include
/// additional fields.
///
/// Generated class from Pigeon that represents data sent in messages.
struct VideoPlayerEventMessage {
  /// The type of event.
  var type: String
  /// Playback state (for playbackStateChanged events).
  var state: PlaybackStateEnum? = nil
  /// Position in milliseconds (for positionChanged events).
  var positionMs: Int64? = nil
  /// Buffered position in milliseconds (for bufferedPositionChanged events).
  var bufferedPositionMs: Int64? = nil
  /// Duration in milliseconds (for durationChanged events).
  var durationMs: Int64? = nil
  /// Error message (for error events).
  var errorMessage: String? = nil
  /// Error code (for error events).
  var errorCode: String? = nil
  /// Video width (for videoSizeChanged events).
  var width: Int64? = nil
  /// Video height (for videoSizeChanged events).
  var height: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> VideoPlayerEventMessage? {
    let type = pigeonVar_list[0] as! String
    let state: PlaybackStateEnum? = nilOrValue(pigeonVar_list[1])
    let positionMs: Int64? = nilOrValue(pigeonVar_list[2])
    let bufferedPositionMs: Int64? = nilOrValue(pigeonVar_list[3])
    let durationMs: Int64? = nilOrValue(pigeonVar_list[4])
    let errorMessage: String? = nilOrValue(pigeonVar_list[5])
    let errorCode: String? = nilOrValue(pigeonVar_list[6])
    let width: Int64? = nilOrValue(pigeonVar_list[7])
    let height: Int64? = nilOrValue(pigeonVar_list[8])

    return VideoPlayerEventMessage(
      type: type,
      state: state,
      positionMs: positionMs,
      bufferedPositionMs: bufferedPositionMs,
      durationMs: durationMs,
      errorMessage: errorMessage,
      errorCode: errorCode,
      width: width,
      height: height
    )
  }
  func toList() -> [Any?] {
    return [
      type,
      state,
      positionMs,
      bufferedPositionMs,
      durationMs,
      errorMessage,
      errorCode,
      width,
      height,
    ]
  }
}

private class PigeonMessagesPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return VideoSourceType(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return VideoScalingModeEnum(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return SubtitleRenderModeEnum(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ControlsModeEnum(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CastStateEnum(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CastDeviceTypeEnum(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PipActionTypeEnum(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return SubtitleFormatEnum(rawValue: enumResultAsInt)
      }
      return nil
    case 137:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PlaybackStateEnum(rawValue: enumResultAsInt)
      }
      return nil
    case 138:
      return VideoSourceMessage.fromList(self.readValue() as! [Any?])
    case 139:
      return VideoPlayerOptionsMessage.fromList(self.readValue() as! [Any?])
    case 140:
      return PlatformInfoMessage.fromList(self.readValue() as! [Any?])
    case 141:
      return BatteryInfoMessage.fromList(self.readValue() as! [Any?])
    case 142:
      return SubtitleTrackMessage.fromList(self.readValue() as! [Any?])
    case 143:
      return AudioTrackMessage.fromList(self.readValue() as! [Any?])
    case 144:
      return VideoQualityTrackMessage.fromList(self.readValue() as! [Any?])
    case 145:
      return PipOptionsMessage.fromList(self.readValue() as! [Any?])
    case 146:
      return PipActionMessage.fromList(self.readValue() as! [Any?])
    case 147:
      return CastDeviceMessage.fromList(self.readValue() as! [Any?])
    case 148:
      return VideoMetadataMessage.fromList(self.readValue() as! [Any?])
    case 149:
      return MediaMetadataMessage.fromList(self.readValue() as! [Any?])
    case 150:
      return SubtitleSourceMessage.fromList(self.readValue() as! [Any?])
    case 151:
      return ExternalSubtitleTrackMessage.fromList(self.readValue() as! [Any?])
    case 152:
      return VideoPlayerEventMessage.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class PigeonMessagesPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? VideoSourceType {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? VideoScalingModeEnum {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? SubtitleRenderModeEnum {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? ControlsModeEnum {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? CastStateEnum {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? CastDeviceTypeEnum {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? PipActionTypeEnum {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? SubtitleFormatEnum {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? PlaybackStateEnum {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? VideoSourceMessage {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? VideoPlayerOptionsMessage {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? PlatformInfoMessage {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? BatteryInfoMessage {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? SubtitleTrackMessage {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? AudioTrackMessage {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? VideoQualityTrackMessage {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else if let value = value as? PipOptionsMessage {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? PipActionMessage {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else if let value = value as? CastDeviceMessage {
      super.writeByte(147)
      super.writeValue(value.toList())
    } else if let value = value as? VideoMetadataMessage {
      super.writeByte(148)
      super.writeValue(value.toList())
    } else if let value = value as? MediaMetadataMessage {
      super.writeByte(149)
      super.writeValue(value.toList())
    } else if let value = value as? SubtitleSourceMessage {
      super.writeByte(150)
      super.writeValue(value.toList())
    } else if let value = value as? ExternalSubtitleTrackMessage {
      super.writeByte(151)
      super.writeValue(value.toList())
    } else if let value = value as? VideoPlayerEventMessage {
      super.writeByte(152)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class PigeonMessagesPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PigeonMessagesPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PigeonMessagesPigeonCodecWriter(data: data)
  }
}

class PigeonMessagesPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = PigeonMessagesPigeonCodec(readerWriter: PigeonMessagesPigeonCodecReaderWriter())
}


/// Host API for video player platform methods.
///
/// This API is implemented on the native platform (iOS, Android, etc.)
/// and called from Dart.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol ProVideoPlayerHostApi {
  /// Creates a new video player instance with the given source and options.
  ///
  /// Returns the player ID that should be used for all subsequent operations.
  func create(source: VideoSourceMessage, options: VideoPlayerOptionsMessage, completion: @escaping (Result<Int64, Error>) -> Void)
  /// Disposes a video player instance.
  func dispose(playerId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  /// Starts playback.
  func play(playerId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  /// Pauses playback.
  func pause(playerId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  /// Stops playback.
  func stop(playerId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  /// Seeks to the specified position.
  ///
  /// [positionMs] is the position in milliseconds.
  func seekTo(playerId: Int64, positionMs: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  /// Sets the playback speed.
  func setPlaybackSpeed(playerId: Int64, speed: Double, completion: @escaping (Result<Void, Error>) -> Void)
  /// Sets the volume (0.0 to 1.0).
  func setVolume(playerId: Int64, volume: Double, completion: @escaping (Result<Void, Error>) -> Void)
  /// Gets the current playback position in milliseconds.
  func getPosition(playerId: Int64, completion: @escaping (Result<Int64, Error>) -> Void)
  /// Gets the video duration in milliseconds.
  func getDuration(playerId: Int64, completion: @escaping (Result<Int64, Error>) -> Void)
  /// Gets static platform information.
  func getPlatformInfo(completion: @escaping (Result<PlatformInfoMessage, Error>) -> Void)
  /// Enables or disables verbose logging.
  func setVerboseLogging(enabled: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  /// Checks if Picture-in-Picture mode is supported.
  func supportsPictureInPicture(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if fullscreen mode is supported.
  func supportsFullscreen(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if background playback is supported.
  func supportsBackgroundPlayback(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if any form of casting is supported.
  func supportsCasting(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if AirPlay is supported.
  func supportsAirPlay(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if Chromecast is supported.
  func supportsChromecast(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if Remote Playback API is supported.
  func supportsRemotePlayback(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if quality selection is supported.
  func supportsQualitySelection(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if playback speed control is supported.
  func supportsPlaybackSpeedControl(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if subtitles are supported.
  func supportsSubtitles(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if external subtitles are supported.
  func supportsExternalSubtitles(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if audio track selection is supported.
  func supportsAudioTrackSelection(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if chapters are supported.
  func supportsChapters(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if video metadata extraction is supported.
  func supportsVideoMetadataExtraction(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if network monitoring is supported.
  func supportsNetworkMonitoring(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if bandwidth estimation is supported.
  func supportsBandwidthEstimation(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if adaptive bitrate streaming is supported.
  func supportsAdaptiveBitrate(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if HLS is supported.
  func supportsHLS(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if DASH is supported.
  func supportsDASH(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if device volume control is supported.
  func supportsDeviceVolumeControl(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if screen brightness control is supported.
  func supportsScreenBrightnessControl(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Gets the device volume (0.0 to 1.0).
  func getDeviceVolume(completion: @escaping (Result<Double, Error>) -> Void)
  /// Sets the device volume (0.0 to 1.0).
  func setDeviceVolume(volume: Double, completion: @escaping (Result<Void, Error>) -> Void)
  /// Gets the screen brightness (0.0 to 1.0).
  func getScreenBrightness(completion: @escaping (Result<Double, Error>) -> Void)
  /// Sets the screen brightness (0.0 to 1.0).
  func setScreenBrightness(brightness: Double, completion: @escaping (Result<Void, Error>) -> Void)
  /// Gets the current battery info.
  func getBatteryInfo(completion: @escaping (Result<BatteryInfoMessage?, Error>) -> Void)
  /// Sets whether the video should loop.
  func setLooping(playerId: Int64, looping: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  /// Sets the video scaling mode.
  func setScalingMode(playerId: Int64, mode: VideoScalingModeEnum, completion: @escaping (Result<Void, Error>) -> Void)
  /// Sets the controls mode.
  func setControlsMode(playerId: Int64, mode: ControlsModeEnum, completion: @escaping (Result<Void, Error>) -> Void)
  /// Sets the active subtitle track.
  func setSubtitleTrack(playerId: Int64, track: SubtitleTrackMessage?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Sets the subtitle render mode.
  func setSubtitleRenderMode(playerId: Int64, mode: SubtitleRenderModeEnum, completion: @escaping (Result<Void, Error>) -> Void)
  /// Adds an external subtitle file.
  func addExternalSubtitle(playerId: Int64, source: SubtitleSourceMessage, completion: @escaping (Result<ExternalSubtitleTrackMessage?, Error>) -> Void)
  /// Removes an external subtitle track.
  func removeExternalSubtitle(playerId: Int64, trackId: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Gets all external subtitle tracks.
  func getExternalSubtitles(playerId: Int64, completion: @escaping (Result<[ExternalSubtitleTrackMessage?], Error>) -> Void)
  /// Sets the active audio track.
  func setAudioTrack(playerId: Int64, track: AudioTrackMessage?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Enters picture-in-picture mode.
  func enterPip(playerId: Int64, options: PipOptionsMessage, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Exits picture-in-picture mode.
  func exitPip(playerId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  /// Checks if PiP is supported on this platform.
  func isPipSupported(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Sets the actions available in PiP mode.
  func setPipActions(playerId: Int64, actions: [PipActionMessage?], completion: @escaping (Result<Void, Error>) -> Void)
  /// Enters fullscreen mode.
  func enterFullscreen(playerId: Int64, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Exits fullscreen mode.
  func exitFullscreen(playerId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  /// Sets window fullscreen state (desktop platforms).
  func setWindowFullscreen(fullscreen: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  /// Enables or disables background playback.
  func setBackgroundPlayback(playerId: Int64, enabled: Bool, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Checks if background playback is supported.
  func isBackgroundPlaybackSupported(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Gets available video quality tracks.
  func getVideoQualities(playerId: Int64, completion: @escaping (Result<[VideoQualityTrackMessage?], Error>) -> Void)
  /// Sets the video quality track.
  func setVideoQuality(playerId: Int64, track: VideoQualityTrackMessage, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Gets the current video quality track.
  func getCurrentVideoQuality(playerId: Int64, completion: @escaping (Result<VideoQualityTrackMessage, Error>) -> Void)
  /// Checks if quality selection is supported.
  func isQualitySelectionSupported(playerId: Int64, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Gets video metadata.
  func getVideoMetadata(playerId: Int64, completion: @escaping (Result<VideoMetadataMessage?, Error>) -> Void)
  /// Sets media metadata for platform controls.
  func setMediaMetadata(playerId: Int64, metadata: MediaMetadataMessage, completion: @escaping (Result<Void, Error>) -> Void)
  /// Checks if casting is supported on this platform.
  func isCastingSupported(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Gets available cast devices.
  func getAvailableCastDevices(playerId: Int64, completion: @escaping (Result<[CastDeviceMessage?], Error>) -> Void)
  /// Starts casting to a device.
  func startCasting(playerId: Int64, device: CastDeviceMessage?, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Stops casting.
  func stopCasting(playerId: Int64, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Gets the current cast state.
  func getCastState(playerId: Int64, completion: @escaping (Result<CastStateEnum, Error>) -> Void)
  /// Gets the current cast device.
  func getCurrentCastDevice(playerId: Int64, completion: @escaping (Result<CastDeviceMessage?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class ProVideoPlayerHostApiSetup {
  static var codec: FlutterStandardMessageCodec { PigeonMessagesPigeonCodec.shared }
  /// Sets up an instance of `ProVideoPlayerHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: ProVideoPlayerHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Creates a new video player instance with the given source and options.
    ///
    /// Returns the player ID that should be used for all subsequent operations.
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.create\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceArg = args[0] as! VideoSourceMessage
        let optionsArg = args[1] as! VideoPlayerOptionsMessage
        api.create(source: sourceArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    /// Disposes a video player instance.
    let disposeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.dispose\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disposeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.dispose(playerId: playerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      disposeChannel.setMessageHandler(nil)
    }
    /// Starts playback.
    let playChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.play\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.play(playerId: playerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      playChannel.setMessageHandler(nil)
    }
    /// Pauses playback.
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.pause\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.pause(playerId: playerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    /// Stops playback.
    let stopChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.stop\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.stop(playerId: playerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      stopChannel.setMessageHandler(nil)
    }
    /// Seeks to the specified position.
    ///
    /// [positionMs] is the position in milliseconds.
    let seekToChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.seekTo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      seekToChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let positionMsArg = args[1] as! Int64
        api.seekTo(playerId: playerIdArg, positionMs: positionMsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      seekToChannel.setMessageHandler(nil)
    }
    /// Sets the playback speed.
    let setPlaybackSpeedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setPlaybackSpeed\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPlaybackSpeedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let speedArg = args[1] as! Double
        api.setPlaybackSpeed(playerId: playerIdArg, speed: speedArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setPlaybackSpeedChannel.setMessageHandler(nil)
    }
    /// Sets the volume (0.0 to 1.0).
    let setVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setVolume\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVolumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let volumeArg = args[1] as! Double
        api.setVolume(playerId: playerIdArg, volume: volumeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setVolumeChannel.setMessageHandler(nil)
    }
    /// Gets the current playback position in milliseconds.
    let getPositionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getPosition\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPositionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.getPosition(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getPositionChannel.setMessageHandler(nil)
    }
    /// Gets the video duration in milliseconds.
    let getDurationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getDuration\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDurationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.getDuration(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getDurationChannel.setMessageHandler(nil)
    }
    /// Gets static platform information.
    let getPlatformInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getPlatformInfo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPlatformInfoChannel.setMessageHandler { _, reply in
        api.getPlatformInfo { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getPlatformInfoChannel.setMessageHandler(nil)
    }
    /// Enables or disables verbose logging.
    let setVerboseLoggingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setVerboseLogging\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVerboseLoggingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let enabledArg = args[0] as! Bool
        api.setVerboseLogging(enabled: enabledArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setVerboseLoggingChannel.setMessageHandler(nil)
    }
    /// Checks if Picture-in-Picture mode is supported.
    let supportsPictureInPictureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsPictureInPicture\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsPictureInPictureChannel.setMessageHandler { _, reply in
        api.supportsPictureInPicture { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsPictureInPictureChannel.setMessageHandler(nil)
    }
    /// Checks if fullscreen mode is supported.
    let supportsFullscreenChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsFullscreen\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsFullscreenChannel.setMessageHandler { _, reply in
        api.supportsFullscreen { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsFullscreenChannel.setMessageHandler(nil)
    }
    /// Checks if background playback is supported.
    let supportsBackgroundPlaybackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsBackgroundPlayback\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsBackgroundPlaybackChannel.setMessageHandler { _, reply in
        api.supportsBackgroundPlayback { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsBackgroundPlaybackChannel.setMessageHandler(nil)
    }
    /// Checks if any form of casting is supported.
    let supportsCastingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsCasting\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsCastingChannel.setMessageHandler { _, reply in
        api.supportsCasting { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsCastingChannel.setMessageHandler(nil)
    }
    /// Checks if AirPlay is supported.
    let supportsAirPlayChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsAirPlay\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsAirPlayChannel.setMessageHandler { _, reply in
        api.supportsAirPlay { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsAirPlayChannel.setMessageHandler(nil)
    }
    /// Checks if Chromecast is supported.
    let supportsChromecastChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsChromecast\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsChromecastChannel.setMessageHandler { _, reply in
        api.supportsChromecast { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsChromecastChannel.setMessageHandler(nil)
    }
    /// Checks if Remote Playback API is supported.
    let supportsRemotePlaybackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsRemotePlayback\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsRemotePlaybackChannel.setMessageHandler { _, reply in
        api.supportsRemotePlayback { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsRemotePlaybackChannel.setMessageHandler(nil)
    }
    /// Checks if quality selection is supported.
    let supportsQualitySelectionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsQualitySelection\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsQualitySelectionChannel.setMessageHandler { _, reply in
        api.supportsQualitySelection { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsQualitySelectionChannel.setMessageHandler(nil)
    }
    /// Checks if playback speed control is supported.
    let supportsPlaybackSpeedControlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsPlaybackSpeedControl\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsPlaybackSpeedControlChannel.setMessageHandler { _, reply in
        api.supportsPlaybackSpeedControl { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsPlaybackSpeedControlChannel.setMessageHandler(nil)
    }
    /// Checks if subtitles are supported.
    let supportsSubtitlesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsSubtitles\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsSubtitlesChannel.setMessageHandler { _, reply in
        api.supportsSubtitles { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsSubtitlesChannel.setMessageHandler(nil)
    }
    /// Checks if external subtitles are supported.
    let supportsExternalSubtitlesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsExternalSubtitles\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsExternalSubtitlesChannel.setMessageHandler { _, reply in
        api.supportsExternalSubtitles { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsExternalSubtitlesChannel.setMessageHandler(nil)
    }
    /// Checks if audio track selection is supported.
    let supportsAudioTrackSelectionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsAudioTrackSelection\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsAudioTrackSelectionChannel.setMessageHandler { _, reply in
        api.supportsAudioTrackSelection { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsAudioTrackSelectionChannel.setMessageHandler(nil)
    }
    /// Checks if chapters are supported.
    let supportsChaptersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsChapters\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsChaptersChannel.setMessageHandler { _, reply in
        api.supportsChapters { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsChaptersChannel.setMessageHandler(nil)
    }
    /// Checks if video metadata extraction is supported.
    let supportsVideoMetadataExtractionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsVideoMetadataExtraction\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsVideoMetadataExtractionChannel.setMessageHandler { _, reply in
        api.supportsVideoMetadataExtraction { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsVideoMetadataExtractionChannel.setMessageHandler(nil)
    }
    /// Checks if network monitoring is supported.
    let supportsNetworkMonitoringChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsNetworkMonitoring\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsNetworkMonitoringChannel.setMessageHandler { _, reply in
        api.supportsNetworkMonitoring { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsNetworkMonitoringChannel.setMessageHandler(nil)
    }
    /// Checks if bandwidth estimation is supported.
    let supportsBandwidthEstimationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsBandwidthEstimation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsBandwidthEstimationChannel.setMessageHandler { _, reply in
        api.supportsBandwidthEstimation { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsBandwidthEstimationChannel.setMessageHandler(nil)
    }
    /// Checks if adaptive bitrate streaming is supported.
    let supportsAdaptiveBitrateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsAdaptiveBitrate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsAdaptiveBitrateChannel.setMessageHandler { _, reply in
        api.supportsAdaptiveBitrate { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsAdaptiveBitrateChannel.setMessageHandler(nil)
    }
    /// Checks if HLS is supported.
    let supportsHLSChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsHLS\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsHLSChannel.setMessageHandler { _, reply in
        api.supportsHLS { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsHLSChannel.setMessageHandler(nil)
    }
    /// Checks if DASH is supported.
    let supportsDASHChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsDASH\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsDASHChannel.setMessageHandler { _, reply in
        api.supportsDASH { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsDASHChannel.setMessageHandler(nil)
    }
    /// Checks if device volume control is supported.
    let supportsDeviceVolumeControlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsDeviceVolumeControl\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsDeviceVolumeControlChannel.setMessageHandler { _, reply in
        api.supportsDeviceVolumeControl { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsDeviceVolumeControlChannel.setMessageHandler(nil)
    }
    /// Checks if screen brightness control is supported.
    let supportsScreenBrightnessControlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsScreenBrightnessControl\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsScreenBrightnessControlChannel.setMessageHandler { _, reply in
        api.supportsScreenBrightnessControl { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsScreenBrightnessControlChannel.setMessageHandler(nil)
    }
    /// Gets the device volume (0.0 to 1.0).
    let getDeviceVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getDeviceVolume\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDeviceVolumeChannel.setMessageHandler { _, reply in
        api.getDeviceVolume { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getDeviceVolumeChannel.setMessageHandler(nil)
    }
    /// Sets the device volume (0.0 to 1.0).
    let setDeviceVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setDeviceVolume\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setDeviceVolumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let volumeArg = args[0] as! Double
        api.setDeviceVolume(volume: volumeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setDeviceVolumeChannel.setMessageHandler(nil)
    }
    /// Gets the screen brightness (0.0 to 1.0).
    let getScreenBrightnessChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getScreenBrightness\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getScreenBrightnessChannel.setMessageHandler { _, reply in
        api.getScreenBrightness { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getScreenBrightnessChannel.setMessageHandler(nil)
    }
    /// Sets the screen brightness (0.0 to 1.0).
    let setScreenBrightnessChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setScreenBrightness\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setScreenBrightnessChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let brightnessArg = args[0] as! Double
        api.setScreenBrightness(brightness: brightnessArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setScreenBrightnessChannel.setMessageHandler(nil)
    }
    /// Gets the current battery info.
    let getBatteryInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getBatteryInfo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getBatteryInfoChannel.setMessageHandler { _, reply in
        api.getBatteryInfo { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getBatteryInfoChannel.setMessageHandler(nil)
    }
    /// Sets whether the video should loop.
    let setLoopingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setLooping\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLoopingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let loopingArg = args[1] as! Bool
        api.setLooping(playerId: playerIdArg, looping: loopingArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setLoopingChannel.setMessageHandler(nil)
    }
    /// Sets the video scaling mode.
    let setScalingModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setScalingMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setScalingModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let modeArg = args[1] as! VideoScalingModeEnum
        api.setScalingMode(playerId: playerIdArg, mode: modeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setScalingModeChannel.setMessageHandler(nil)
    }
    /// Sets the controls mode.
    let setControlsModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setControlsMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setControlsModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let modeArg = args[1] as! ControlsModeEnum
        api.setControlsMode(playerId: playerIdArg, mode: modeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setControlsModeChannel.setMessageHandler(nil)
    }
    /// Sets the active subtitle track.
    let setSubtitleTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setSubtitleTrack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSubtitleTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let trackArg: SubtitleTrackMessage? = nilOrValue(args[1])
        api.setSubtitleTrack(playerId: playerIdArg, track: trackArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSubtitleTrackChannel.setMessageHandler(nil)
    }
    /// Sets the subtitle render mode.
    let setSubtitleRenderModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setSubtitleRenderMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSubtitleRenderModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let modeArg = args[1] as! SubtitleRenderModeEnum
        api.setSubtitleRenderMode(playerId: playerIdArg, mode: modeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSubtitleRenderModeChannel.setMessageHandler(nil)
    }
    /// Adds an external subtitle file.
    let addExternalSubtitleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.addExternalSubtitle\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addExternalSubtitleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let sourceArg = args[1] as! SubtitleSourceMessage
        api.addExternalSubtitle(playerId: playerIdArg, source: sourceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addExternalSubtitleChannel.setMessageHandler(nil)
    }
    /// Removes an external subtitle track.
    let removeExternalSubtitleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.removeExternalSubtitle\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeExternalSubtitleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let trackIdArg = args[1] as! String
        api.removeExternalSubtitle(playerId: playerIdArg, trackId: trackIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeExternalSubtitleChannel.setMessageHandler(nil)
    }
    /// Gets all external subtitle tracks.
    let getExternalSubtitlesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getExternalSubtitles\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getExternalSubtitlesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.getExternalSubtitles(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getExternalSubtitlesChannel.setMessageHandler(nil)
    }
    /// Sets the active audio track.
    let setAudioTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setAudioTrack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAudioTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let trackArg: AudioTrackMessage? = nilOrValue(args[1])
        api.setAudioTrack(playerId: playerIdArg, track: trackArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setAudioTrackChannel.setMessageHandler(nil)
    }
    /// Enters picture-in-picture mode.
    let enterPipChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.enterPip\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enterPipChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let optionsArg = args[1] as! PipOptionsMessage
        api.enterPip(playerId: playerIdArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      enterPipChannel.setMessageHandler(nil)
    }
    /// Exits picture-in-picture mode.
    let exitPipChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.exitPip\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exitPipChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.exitPip(playerId: playerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exitPipChannel.setMessageHandler(nil)
    }
    /// Checks if PiP is supported on this platform.
    let isPipSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.isPipSupported\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPipSupportedChannel.setMessageHandler { _, reply in
        api.isPipSupported { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isPipSupportedChannel.setMessageHandler(nil)
    }
    /// Sets the actions available in PiP mode.
    let setPipActionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setPipActions\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPipActionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let actionsArg = args[1] as! [PipActionMessage?]
        api.setPipActions(playerId: playerIdArg, actions: actionsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setPipActionsChannel.setMessageHandler(nil)
    }
    /// Enters fullscreen mode.
    let enterFullscreenChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.enterFullscreen\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enterFullscreenChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.enterFullscreen(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      enterFullscreenChannel.setMessageHandler(nil)
    }
    /// Exits fullscreen mode.
    let exitFullscreenChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.exitFullscreen\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exitFullscreenChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.exitFullscreen(playerId: playerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exitFullscreenChannel.setMessageHandler(nil)
    }
    /// Sets window fullscreen state (desktop platforms).
    let setWindowFullscreenChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setWindowFullscreen\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setWindowFullscreenChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fullscreenArg = args[0] as! Bool
        api.setWindowFullscreen(fullscreen: fullscreenArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setWindowFullscreenChannel.setMessageHandler(nil)
    }
    /// Enables or disables background playback.
    let setBackgroundPlaybackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setBackgroundPlayback\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setBackgroundPlaybackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let enabledArg = args[1] as! Bool
        api.setBackgroundPlayback(playerId: playerIdArg, enabled: enabledArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setBackgroundPlaybackChannel.setMessageHandler(nil)
    }
    /// Checks if background playback is supported.
    let isBackgroundPlaybackSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.isBackgroundPlaybackSupported\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isBackgroundPlaybackSupportedChannel.setMessageHandler { _, reply in
        api.isBackgroundPlaybackSupported { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isBackgroundPlaybackSupportedChannel.setMessageHandler(nil)
    }
    /// Gets available video quality tracks.
    let getVideoQualitiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getVideoQualities\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoQualitiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.getVideoQualities(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getVideoQualitiesChannel.setMessageHandler(nil)
    }
    /// Sets the video quality track.
    let setVideoQualityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setVideoQuality\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVideoQualityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let trackArg = args[1] as! VideoQualityTrackMessage
        api.setVideoQuality(playerId: playerIdArg, track: trackArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setVideoQualityChannel.setMessageHandler(nil)
    }
    /// Gets the current video quality track.
    let getCurrentVideoQualityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getCurrentVideoQuality\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentVideoQualityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.getCurrentVideoQuality(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCurrentVideoQualityChannel.setMessageHandler(nil)
    }
    /// Checks if quality selection is supported.
    let isQualitySelectionSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.isQualitySelectionSupported\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isQualitySelectionSupportedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.isQualitySelectionSupported(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isQualitySelectionSupportedChannel.setMessageHandler(nil)
    }
    /// Gets video metadata.
    let getVideoMetadataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getVideoMetadata\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoMetadataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.getVideoMetadata(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getVideoMetadataChannel.setMessageHandler(nil)
    }
    /// Sets media metadata for platform controls.
    let setMediaMetadataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setMediaMetadata\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setMediaMetadataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let metadataArg = args[1] as! MediaMetadataMessage
        api.setMediaMetadata(playerId: playerIdArg, metadata: metadataArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setMediaMetadataChannel.setMessageHandler(nil)
    }
    /// Checks if casting is supported on this platform.
    let isCastingSupportedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.isCastingSupported\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isCastingSupportedChannel.setMessageHandler { _, reply in
        api.isCastingSupported { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isCastingSupportedChannel.setMessageHandler(nil)
    }
    /// Gets available cast devices.
    let getAvailableCastDevicesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getAvailableCastDevices\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAvailableCastDevicesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.getAvailableCastDevices(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAvailableCastDevicesChannel.setMessageHandler(nil)
    }
    /// Starts casting to a device.
    let startCastingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.startCasting\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startCastingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let deviceArg: CastDeviceMessage? = nilOrValue(args[1])
        api.startCasting(playerId: playerIdArg, device: deviceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      startCastingChannel.setMessageHandler(nil)
    }
    /// Stops casting.
    let stopCastingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.stopCasting\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopCastingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.stopCasting(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      stopCastingChannel.setMessageHandler(nil)
    }
    /// Gets the current cast state.
    let getCastStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getCastState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCastStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.getCastState(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCastStateChannel.setMessageHandler(nil)
    }
    /// Gets the current cast device.
    let getCurrentCastDeviceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getCurrentCastDevice\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentCastDeviceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.getCurrentCastDevice(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCurrentCastDeviceChannel.setMessageHandler(nil)
    }
  }
}
/// Flutter API for callbacks from the platform to Dart.
///
/// This API is implemented in Dart and called from the native platform
/// to send events.
///
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol ProVideoPlayerFlutterApiProtocol {
  /// Called when a video player event occurs.
  func onEvent(playerId playerIdArg: Int64, event eventArg: VideoPlayerEventMessage, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class ProVideoPlayerFlutterApi: ProVideoPlayerFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PigeonMessagesPigeonCodec {
    return PigeonMessagesPigeonCodec.shared
  }
  /// Called when a video player event occurs.
  func onEvent(playerId playerIdArg: Int64, event eventArg: VideoPlayerEventMessage, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerFlutterApi.onEvent\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([playerIdArg, eventArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
