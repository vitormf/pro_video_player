// Copyright 2025 The Pro Video Player Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.7.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package dev.pro_video_player.pro_video_player_android

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlutterError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): FlutterError {
  return FlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Video source types supported by the platform. */
enum class VideoSourceType(val raw: Int) {
  /** Network video source (HTTP/HTTPS URL). */
  NETWORK(0),
  /** Local file video source. */
  FILE(1),
  /** Asset video source (bundled with the app). */
  ASSET(2);

  companion object {
    fun ofRaw(raw: Int): VideoSourceType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Video scaling modes. */
enum class VideoScalingModeEnum(val raw: Int) {
  /** Fit the video within the view (letterbox/pillarbox). */
  FIT(0),
  /** Fill the entire view (may crop video). */
  FILL(1),
  /** Stretch the video to fill the view. */
  STRETCH(2);

  companion object {
    fun ofRaw(raw: Int): VideoScalingModeEnum? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Subtitle render modes. */
enum class SubtitleRenderModeEnum(val raw: Int) {
  /** Auto-select best render mode. */
  AUTO(0),
  /** Render subtitles natively. */
  NATIVE(1),
  /** Render subtitles in Flutter. */
  FLUTTER(2);

  companion object {
    fun ofRaw(raw: Int): SubtitleRenderModeEnum? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Controls mode. */
enum class ControlsModeEnum(val raw: Int) {
  /** Video only, no controls. */
  VIDEO_ONLY(0),
  /** Native platform controls. */
  NATIVE_CONTROLS(1),
  /** Flutter controls. */
  FLUTTER_CONTROLS(2),
  /** Custom controls. */
  CUSTOM_CONTROLS(3);

  companion object {
    fun ofRaw(raw: Int): ControlsModeEnum? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Cast state. */
enum class CastStateEnum(val raw: Int) {
  /** Not connected to any cast device. */
  NOT_CONNECTED(0),
  /** Connecting to cast device. */
  CONNECTING(1),
  /** Connected to cast device. */
  CONNECTED(2),
  /** Disconnecting from cast device. */
  DISCONNECTING(3);

  companion object {
    fun ofRaw(raw: Int): CastStateEnum? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Cast device type. */
enum class CastDeviceTypeEnum(val raw: Int) {
  /** AirPlay device. */
  AIR_PLAY(0),
  /** Chromecast device. */
  CHROMECAST(1),
  /** Web Remote Playback device. */
  WEB_REMOTE_PLAYBACK(2),
  /** Unknown device type. */
  UNKNOWN(3);

  companion object {
    fun ofRaw(raw: Int): CastDeviceTypeEnum? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** PiP action type. */
enum class PipActionTypeEnum(val raw: Int) {
  /** Play/pause toggle. */
  PLAY_PAUSE(0),
  /** Skip to previous. */
  SKIP_PREVIOUS(1),
  /** Skip to next. */
  SKIP_NEXT(2),
  /** Skip backward. */
  SKIP_BACKWARD(3),
  /** Skip forward. */
  SKIP_FORWARD(4);

  companion object {
    fun ofRaw(raw: Int): PipActionTypeEnum? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Subtitle format. */
enum class SubtitleFormatEnum(val raw: Int) {
  /** SRT format. */
  SRT(0),
  /** WebVTT format. */
  VTT(1),
  /** SSA format. */
  SSA(2),
  /** ASS format. */
  ASS(3),
  /** TTML format. */
  TTML(4);

  companion object {
    fun ofRaw(raw: Int): SubtitleFormatEnum? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Playback state enumeration. */
enum class PlaybackStateEnum(val raw: Int) {
  /** Player is uninitialized. */
  UNINITIALIZED(0),
  /** Player is initializing. */
  INITIALIZING(1),
  /** Player is ready to play. */
  READY(2),
  /** Player is playing. */
  PLAYING(3),
  /** Player is paused. */
  PAUSED(4),
  /** Playback has completed. */
  COMPLETED(5),
  /** Player is buffering. */
  BUFFERING(6),
  /** Player encountered an error. */
  ERROR(7),
  /** Player has been disposed. */
  DISPOSED(8);

  companion object {
    fun ofRaw(raw: Int): PlaybackStateEnum? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Video source data passed to the platform.
 *
 * This represents the video source to be played. Only one of [url], [path],
 * or [assetPath] should be set based on the [type].
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VideoSourceMessage (
  /** The type of video source. */
  val type: VideoSourceType,
  /** Network URL (for network sources). */
  val url: String? = null,
  /** File path (for file sources). */
  val path: String? = null,
  /** Asset path (for asset sources). */
  val assetPath: String? = null,
  /** HTTP headers (for network sources). */
  val headers: Map<String?, String?>? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VideoSourceMessage {
      val type = pigeonVar_list[0] as VideoSourceType
      val url = pigeonVar_list[1] as String?
      val path = pigeonVar_list[2] as String?
      val assetPath = pigeonVar_list[3] as String?
      val headers = pigeonVar_list[4] as Map<String?, String?>?
      return VideoSourceMessage(type, url, path, assetPath, headers)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      type,
      url,
      path,
      assetPath,
      headers,
    )
  }
}

/**
 * Video player options for initialization.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VideoPlayerOptionsMessage (
  /** Whether to start playing automatically after initialization. */
  val autoPlay: Boolean,
  /** Whether to loop the video. */
  val looping: Boolean,
  /** Initial volume (0.0 to 1.0). */
  val volume: Double,
  /** Initial playback speed. */
  val playbackSpeed: Double,
  /** Start position in milliseconds. */
  val startPosition: Long? = null,
  /** Whether to enable Picture-in-Picture mode. */
  val enablePip: Boolean? = null,
  /** Whether to enable background playback. */
  val enableBackgroundPlayback: Boolean? = null,
  /** Preferred audio language code. */
  val preferredAudioLanguage: String? = null,
  /** Preferred subtitle language code. */
  val preferredSubtitleLanguage: String? = null,
  /** Maximum bitrate in bits per second. */
  val maxBitrate: Long? = null,
  /** Minimum bitrate in bits per second. */
  val minBitrate: Long? = null,
  /** Preferred audio rendition name. */
  val preferredAudioRendition: String? = null,
  /** Whether to allow background playback (deprecated, use enableBackgroundPlayback). */
  val allowBackgroundPlayback: Boolean,
  /** Whether to mix audio with other apps. */
  val mixWithOthers: Boolean,
  /** Whether to allow Picture-in-Picture mode (deprecated, use enablePip). */
  val allowPip: Boolean,
  /** Whether to auto-enter PiP when app goes to background. */
  val autoEnterPipOnBackground: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VideoPlayerOptionsMessage {
      val autoPlay = pigeonVar_list[0] as Boolean
      val looping = pigeonVar_list[1] as Boolean
      val volume = pigeonVar_list[2] as Double
      val playbackSpeed = pigeonVar_list[3] as Double
      val startPosition = pigeonVar_list[4] as Long?
      val enablePip = pigeonVar_list[5] as Boolean?
      val enableBackgroundPlayback = pigeonVar_list[6] as Boolean?
      val preferredAudioLanguage = pigeonVar_list[7] as String?
      val preferredSubtitleLanguage = pigeonVar_list[8] as String?
      val maxBitrate = pigeonVar_list[9] as Long?
      val minBitrate = pigeonVar_list[10] as Long?
      val preferredAudioRendition = pigeonVar_list[11] as String?
      val allowBackgroundPlayback = pigeonVar_list[12] as Boolean
      val mixWithOthers = pigeonVar_list[13] as Boolean
      val allowPip = pigeonVar_list[14] as Boolean
      val autoEnterPipOnBackground = pigeonVar_list[15] as Boolean
      return VideoPlayerOptionsMessage(autoPlay, looping, volume, playbackSpeed, startPosition, enablePip, enableBackgroundPlayback, preferredAudioLanguage, preferredSubtitleLanguage, maxBitrate, minBitrate, preferredAudioRendition, allowBackgroundPlayback, mixWithOthers, allowPip, autoEnterPipOnBackground)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      autoPlay,
      looping,
      volume,
      playbackSpeed,
      startPosition,
      enablePip,
      enableBackgroundPlayback,
      preferredAudioLanguage,
      preferredSubtitleLanguage,
      maxBitrate,
      minBitrate,
      preferredAudioRendition,
      allowBackgroundPlayback,
      mixWithOthers,
      allowPip,
      autoEnterPipOnBackground,
    )
  }
}

/**
 * Platform information returned by the platform.
 *
 * Contains static platform metadata that doesn't require async checks.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class PlatformInfoMessage (
  /** Platform name (e.g., "iOS", "Android", "Web"). */
  val platformName: String,
  /** Native player type (e.g., "AVPlayer", "ExoPlayer", "HTML5"). */
  val nativePlayerType: String,
  /**
   * Additional platform-specific information as key-value pairs.
   *
   * May include:
   * - OS version
   * - SDK version
   * - Browser user agent
   * - Hardware capabilities
   */
  val additionalInfo: Map<String?, Any?>? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PlatformInfoMessage {
      val platformName = pigeonVar_list[0] as String
      val nativePlayerType = pigeonVar_list[1] as String
      val additionalInfo = pigeonVar_list[2] as Map<String?, Any?>?
      return PlatformInfoMessage(platformName, nativePlayerType, additionalInfo)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      platformName,
      nativePlayerType,
      additionalInfo,
    )
  }
}

/**
 * Battery information.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class BatteryInfoMessage (
  /** Battery percentage (0-100). */
  val percentage: Long,
  /** Whether the device is charging. */
  val isCharging: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): BatteryInfoMessage {
      val percentage = pigeonVar_list[0] as Long
      val isCharging = pigeonVar_list[1] as Boolean
      return BatteryInfoMessage(percentage, isCharging)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      percentage,
      isCharging,
    )
  }
}

/**
 * Subtitle track information.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class SubtitleTrackMessage (
  /** Track ID. */
  val id: String,
  /** Track label. */
  val label: String? = null,
  /** Track language code. */
  val language: String? = null,
  /** Subtitle format. */
  val format: SubtitleFormatEnum? = null,
  /** Whether this is the default track. */
  val isDefault: Boolean? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SubtitleTrackMessage {
      val id = pigeonVar_list[0] as String
      val label = pigeonVar_list[1] as String?
      val language = pigeonVar_list[2] as String?
      val format = pigeonVar_list[3] as SubtitleFormatEnum?
      val isDefault = pigeonVar_list[4] as Boolean?
      return SubtitleTrackMessage(id, label, language, format, isDefault)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      label,
      language,
      format,
      isDefault,
    )
  }
}

/**
 * Audio track information.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class AudioTrackMessage (
  /** Track ID. */
  val id: String,
  /** Track label. */
  val label: String? = null,
  /** Track language code. */
  val language: String? = null,
  /** Number of audio channels. */
  val channelCount: Long? = null,
  /** Whether this is the default track. */
  val isDefault: Boolean? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): AudioTrackMessage {
      val id = pigeonVar_list[0] as String
      val label = pigeonVar_list[1] as String?
      val language = pigeonVar_list[2] as String?
      val channelCount = pigeonVar_list[3] as Long?
      val isDefault = pigeonVar_list[4] as Boolean?
      return AudioTrackMessage(id, label, language, channelCount, isDefault)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      label,
      language,
      channelCount,
      isDefault,
    )
  }
}

/**
 * Video quality track information.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VideoQualityTrackMessage (
  /** Track ID. */
  val id: String,
  /** Track label. */
  val label: String? = null,
  /** Bitrate in bits per second. */
  val bitrate: Long? = null,
  /** Video width in pixels. */
  val width: Long? = null,
  /** Video height in pixels. */
  val height: Long? = null,
  /** Video codec. */
  val codec: String? = null,
  /** Whether this is the default track. */
  val isDefault: Boolean? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VideoQualityTrackMessage {
      val id = pigeonVar_list[0] as String
      val label = pigeonVar_list[1] as String?
      val bitrate = pigeonVar_list[2] as Long?
      val width = pigeonVar_list[3] as Long?
      val height = pigeonVar_list[4] as Long?
      val codec = pigeonVar_list[5] as String?
      val isDefault = pigeonVar_list[6] as Boolean?
      return VideoQualityTrackMessage(id, label, bitrate, width, height, codec, isDefault)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      label,
      bitrate,
      width,
      height,
      codec,
      isDefault,
    )
  }
}

/**
 * Picture-in-picture options.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class PipOptionsMessage (
  /** Aspect ratio (width / height). */
  val aspectRatio: Double? = null,
  /** Auto-enter PiP when app goes to background. */
  val autoEnterOnBackground: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PipOptionsMessage {
      val aspectRatio = pigeonVar_list[0] as Double?
      val autoEnterOnBackground = pigeonVar_list[1] as Boolean
      return PipOptionsMessage(aspectRatio, autoEnterOnBackground)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      aspectRatio,
      autoEnterOnBackground,
    )
  }
}

/**
 * Picture-in-picture action.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class PipActionMessage (
  /** Action type. */
  val type: PipActionTypeEnum,
  /** Action title. */
  val title: String? = null,
  /** Icon name. */
  val iconName: String? = null,
  /** Optional skip interval in milliseconds. */
  val skipIntervalMs: Long? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PipActionMessage {
      val type = pigeonVar_list[0] as PipActionTypeEnum
      val title = pigeonVar_list[1] as String?
      val iconName = pigeonVar_list[2] as String?
      val skipIntervalMs = pigeonVar_list[3] as Long?
      return PipActionMessage(type, title, iconName, skipIntervalMs)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      type,
      title,
      iconName,
      skipIntervalMs,
    )
  }
}

/**
 * Cast device information.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CastDeviceMessage (
  /** Device ID. */
  val id: String,
  /** Device name. */
  val name: String,
  /** Device type. */
  val type: CastDeviceTypeEnum
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CastDeviceMessage {
      val id = pigeonVar_list[0] as String
      val name = pigeonVar_list[1] as String
      val type = pigeonVar_list[2] as CastDeviceTypeEnum
      return CastDeviceMessage(id, name, type)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      name,
      type,
    )
  }
}

/**
 * Video metadata.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VideoMetadataMessage (
  /** Duration in milliseconds. */
  val duration: Long? = null,
  /** Video width in pixels. */
  val width: Long? = null,
  /** Video height in pixels. */
  val height: Long? = null,
  /** Video codec. */
  val videoCodec: String? = null,
  /** Audio codec. */
  val audioCodec: String? = null,
  /** Bitrate in bits per second. */
  val bitrate: Long? = null,
  /** Frame rate. */
  val frameRate: Double? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VideoMetadataMessage {
      val duration = pigeonVar_list[0] as Long?
      val width = pigeonVar_list[1] as Long?
      val height = pigeonVar_list[2] as Long?
      val videoCodec = pigeonVar_list[3] as String?
      val audioCodec = pigeonVar_list[4] as String?
      val bitrate = pigeonVar_list[5] as Long?
      val frameRate = pigeonVar_list[6] as Double?
      return VideoMetadataMessage(duration, width, height, videoCodec, audioCodec, bitrate, frameRate)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      duration,
      width,
      height,
      videoCodec,
      audioCodec,
      bitrate,
      frameRate,
    )
  }
}

/**
 * Media metadata for platform controls.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class MediaMetadataMessage (
  /** Media title. */
  val title: String? = null,
  /** Media artist/author. */
  val artist: String? = null,
  /** Album name. */
  val album: String? = null,
  /** Artwork URL. */
  val artworkUrl: String? = null,
  /** Duration in milliseconds. */
  val duration: Long? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): MediaMetadataMessage {
      val title = pigeonVar_list[0] as String?
      val artist = pigeonVar_list[1] as String?
      val album = pigeonVar_list[2] as String?
      val artworkUrl = pigeonVar_list[3] as String?
      val duration = pigeonVar_list[4] as Long?
      return MediaMetadataMessage(title, artist, album, artworkUrl, duration)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      title,
      artist,
      album,
      artworkUrl,
      duration,
    )
  }
}

/**
 * Subtitle source information.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class SubtitleSourceMessage (
  /** Source type (network, file, asset). */
  val type: VideoSourceType,
  /** Path or URL. */
  val path: String,
  /** Subtitle format. */
  val format: SubtitleFormatEnum? = null,
  /** Track label. */
  val label: String? = null,
  /** Language code. */
  val language: String? = null,
  /** Whether this is the default subtitle. */
  val isDefault: Boolean,
  /** WebVTT content (for in-memory subtitles). */
  val webvttContent: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SubtitleSourceMessage {
      val type = pigeonVar_list[0] as VideoSourceType
      val path = pigeonVar_list[1] as String
      val format = pigeonVar_list[2] as SubtitleFormatEnum?
      val label = pigeonVar_list[3] as String?
      val language = pigeonVar_list[4] as String?
      val isDefault = pigeonVar_list[5] as Boolean
      val webvttContent = pigeonVar_list[6] as String?
      return SubtitleSourceMessage(type, path, format, label, language, isDefault, webvttContent)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      type,
      path,
      format,
      label,
      language,
      isDefault,
      webvttContent,
    )
  }
}

/**
 * External subtitle track information.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ExternalSubtitleTrackMessage (
  /** Track ID. */
  val id: String,
  /** Track label. */
  val label: String,
  /** Track language code. */
  val language: String? = null,
  /** Whether this is the default track. */
  val isDefault: Boolean,
  /** Source path or URL. */
  val path: String,
  /** Source type. */
  val sourceType: String,
  /** Subtitle format. */
  val format: SubtitleFormatEnum
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ExternalSubtitleTrackMessage {
      val id = pigeonVar_list[0] as String
      val label = pigeonVar_list[1] as String
      val language = pigeonVar_list[2] as String?
      val isDefault = pigeonVar_list[3] as Boolean
      val path = pigeonVar_list[4] as String
      val sourceType = pigeonVar_list[5] as String
      val format = pigeonVar_list[6] as SubtitleFormatEnum
      return ExternalSubtitleTrackMessage(id, label, language, isDefault, path, sourceType, format)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      label,
      language,
      isDefault,
      path,
      sourceType,
      format,
    )
  }
}

/**
 * Video player event data sent from the platform to Dart.
 *
 * This is a base class for all events. Specific event types will include
 * additional fields.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VideoPlayerEventMessage (
  /** The type of event. */
  val type: String,
  /** Playback state (for playbackStateChanged events). */
  val state: PlaybackStateEnum? = null,
  /** Position in milliseconds (for positionChanged events). */
  val positionMs: Long? = null,
  /** Buffered position in milliseconds (for bufferedPositionChanged events). */
  val bufferedPositionMs: Long? = null,
  /** Duration in milliseconds (for durationChanged events). */
  val durationMs: Long? = null,
  /** Error message (for error events). */
  val errorMessage: String? = null,
  /** Error code (for error events). */
  val errorCode: String? = null,
  /** Video width (for videoSizeChanged events). */
  val width: Long? = null,
  /** Video height (for videoSizeChanged events). */
  val height: Long? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VideoPlayerEventMessage {
      val type = pigeonVar_list[0] as String
      val state = pigeonVar_list[1] as PlaybackStateEnum?
      val positionMs = pigeonVar_list[2] as Long?
      val bufferedPositionMs = pigeonVar_list[3] as Long?
      val durationMs = pigeonVar_list[4] as Long?
      val errorMessage = pigeonVar_list[5] as String?
      val errorCode = pigeonVar_list[6] as String?
      val width = pigeonVar_list[7] as Long?
      val height = pigeonVar_list[8] as Long?
      return VideoPlayerEventMessage(type, state, positionMs, bufferedPositionMs, durationMs, errorMessage, errorCode, width, height)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      type,
      state,
      positionMs,
      bufferedPositionMs,
      durationMs,
      errorMessage,
      errorCode,
      width,
      height,
    )
  }
}
private open class PigeonMessagesPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          VideoSourceType.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          VideoScalingModeEnum.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          SubtitleRenderModeEnum.ofRaw(it.toInt())
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          ControlsModeEnum.ofRaw(it.toInt())
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          CastStateEnum.ofRaw(it.toInt())
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          CastDeviceTypeEnum.ofRaw(it.toInt())
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PipActionTypeEnum.ofRaw(it.toInt())
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          SubtitleFormatEnum.ofRaw(it.toInt())
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          PlaybackStateEnum.ofRaw(it.toInt())
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VideoSourceMessage.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VideoPlayerOptionsMessage.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PlatformInfoMessage.fromList(it)
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          BatteryInfoMessage.fromList(it)
        }
      }
      142.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SubtitleTrackMessage.fromList(it)
        }
      }
      143.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AudioTrackMessage.fromList(it)
        }
      }
      144.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VideoQualityTrackMessage.fromList(it)
        }
      }
      145.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PipOptionsMessage.fromList(it)
        }
      }
      146.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PipActionMessage.fromList(it)
        }
      }
      147.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CastDeviceMessage.fromList(it)
        }
      }
      148.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VideoMetadataMessage.fromList(it)
        }
      }
      149.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MediaMetadataMessage.fromList(it)
        }
      }
      150.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SubtitleSourceMessage.fromList(it)
        }
      }
      151.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ExternalSubtitleTrackMessage.fromList(it)
        }
      }
      152.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VideoPlayerEventMessage.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is VideoSourceType -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is VideoScalingModeEnum -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is SubtitleRenderModeEnum -> {
        stream.write(131)
        writeValue(stream, value.raw)
      }
      is ControlsModeEnum -> {
        stream.write(132)
        writeValue(stream, value.raw)
      }
      is CastStateEnum -> {
        stream.write(133)
        writeValue(stream, value.raw)
      }
      is CastDeviceTypeEnum -> {
        stream.write(134)
        writeValue(stream, value.raw)
      }
      is PipActionTypeEnum -> {
        stream.write(135)
        writeValue(stream, value.raw)
      }
      is SubtitleFormatEnum -> {
        stream.write(136)
        writeValue(stream, value.raw)
      }
      is PlaybackStateEnum -> {
        stream.write(137)
        writeValue(stream, value.raw)
      }
      is VideoSourceMessage -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is VideoPlayerOptionsMessage -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is PlatformInfoMessage -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      is BatteryInfoMessage -> {
        stream.write(141)
        writeValue(stream, value.toList())
      }
      is SubtitleTrackMessage -> {
        stream.write(142)
        writeValue(stream, value.toList())
      }
      is AudioTrackMessage -> {
        stream.write(143)
        writeValue(stream, value.toList())
      }
      is VideoQualityTrackMessage -> {
        stream.write(144)
        writeValue(stream, value.toList())
      }
      is PipOptionsMessage -> {
        stream.write(145)
        writeValue(stream, value.toList())
      }
      is PipActionMessage -> {
        stream.write(146)
        writeValue(stream, value.toList())
      }
      is CastDeviceMessage -> {
        stream.write(147)
        writeValue(stream, value.toList())
      }
      is VideoMetadataMessage -> {
        stream.write(148)
        writeValue(stream, value.toList())
      }
      is MediaMetadataMessage -> {
        stream.write(149)
        writeValue(stream, value.toList())
      }
      is SubtitleSourceMessage -> {
        stream.write(150)
        writeValue(stream, value.toList())
      }
      is ExternalSubtitleTrackMessage -> {
        stream.write(151)
        writeValue(stream, value.toList())
      }
      is VideoPlayerEventMessage -> {
        stream.write(152)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}


/**
 * Host API for video player platform methods.
 *
 * This API is implemented on the native platform (iOS, Android, etc.)
 * and called from Dart.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface ProVideoPlayerHostApi {
  /**
   * Creates a new video player instance with the given source and options.
   *
   * Returns the player ID that should be used for all subsequent operations.
   */
  fun create(source: VideoSourceMessage, options: VideoPlayerOptionsMessage, callback: (Result<Long>) -> Unit)
  /** Disposes a video player instance. */
  fun dispose(playerId: Long, callback: (Result<Unit>) -> Unit)
  /** Starts playback. */
  fun play(playerId: Long, callback: (Result<Unit>) -> Unit)
  /** Pauses playback. */
  fun pause(playerId: Long, callback: (Result<Unit>) -> Unit)
  /** Stops playback. */
  fun stop(playerId: Long, callback: (Result<Unit>) -> Unit)
  /**
   * Seeks to the specified position.
   *
   * [positionMs] is the position in milliseconds.
   */
  fun seekTo(playerId: Long, positionMs: Long, callback: (Result<Unit>) -> Unit)
  /** Sets the playback speed. */
  fun setPlaybackSpeed(playerId: Long, speed: Double, callback: (Result<Unit>) -> Unit)
  /** Sets the volume (0.0 to 1.0). */
  fun setVolume(playerId: Long, volume: Double, callback: (Result<Unit>) -> Unit)
  /** Gets the current playback position in milliseconds. */
  fun getPosition(playerId: Long, callback: (Result<Long>) -> Unit)
  /** Gets the video duration in milliseconds. */
  fun getDuration(playerId: Long, callback: (Result<Long>) -> Unit)
  /** Gets static platform information. */
  fun getPlatformInfo(callback: (Result<PlatformInfoMessage>) -> Unit)
  /** Enables or disables verbose logging. */
  fun setVerboseLogging(enabled: Boolean, callback: (Result<Unit>) -> Unit)
  /** Checks if Picture-in-Picture mode is supported. */
  fun supportsPictureInPicture(callback: (Result<Boolean>) -> Unit)
  /** Checks if fullscreen mode is supported. */
  fun supportsFullscreen(callback: (Result<Boolean>) -> Unit)
  /** Checks if background playback is supported. */
  fun supportsBackgroundPlayback(callback: (Result<Boolean>) -> Unit)
  /** Checks if any form of casting is supported. */
  fun supportsCasting(callback: (Result<Boolean>) -> Unit)
  /** Checks if AirPlay is supported. */
  fun supportsAirPlay(callback: (Result<Boolean>) -> Unit)
  /** Checks if Chromecast is supported. */
  fun supportsChromecast(callback: (Result<Boolean>) -> Unit)
  /** Checks if Remote Playback API is supported. */
  fun supportsRemotePlayback(callback: (Result<Boolean>) -> Unit)
  /** Checks if quality selection is supported. */
  fun supportsQualitySelection(callback: (Result<Boolean>) -> Unit)
  /** Checks if playback speed control is supported. */
  fun supportsPlaybackSpeedControl(callback: (Result<Boolean>) -> Unit)
  /** Checks if subtitles are supported. */
  fun supportsSubtitles(callback: (Result<Boolean>) -> Unit)
  /** Checks if external subtitles are supported. */
  fun supportsExternalSubtitles(callback: (Result<Boolean>) -> Unit)
  /** Checks if audio track selection is supported. */
  fun supportsAudioTrackSelection(callback: (Result<Boolean>) -> Unit)
  /** Checks if chapters are supported. */
  fun supportsChapters(callback: (Result<Boolean>) -> Unit)
  /** Checks if video metadata extraction is supported. */
  fun supportsVideoMetadataExtraction(callback: (Result<Boolean>) -> Unit)
  /** Checks if network monitoring is supported. */
  fun supportsNetworkMonitoring(callback: (Result<Boolean>) -> Unit)
  /** Checks if bandwidth estimation is supported. */
  fun supportsBandwidthEstimation(callback: (Result<Boolean>) -> Unit)
  /** Checks if adaptive bitrate streaming is supported. */
  fun supportsAdaptiveBitrate(callback: (Result<Boolean>) -> Unit)
  /** Checks if HLS is supported. */
  fun supportsHLS(callback: (Result<Boolean>) -> Unit)
  /** Checks if DASH is supported. */
  fun supportsDASH(callback: (Result<Boolean>) -> Unit)
  /** Checks if device volume control is supported. */
  fun supportsDeviceVolumeControl(callback: (Result<Boolean>) -> Unit)
  /** Checks if screen brightness control is supported. */
  fun supportsScreenBrightnessControl(callback: (Result<Boolean>) -> Unit)
  /** Gets the device volume (0.0 to 1.0). */
  fun getDeviceVolume(callback: (Result<Double>) -> Unit)
  /** Sets the device volume (0.0 to 1.0). */
  fun setDeviceVolume(volume: Double, callback: (Result<Unit>) -> Unit)
  /** Gets the screen brightness (0.0 to 1.0). */
  fun getScreenBrightness(callback: (Result<Double>) -> Unit)
  /** Sets the screen brightness (0.0 to 1.0). */
  fun setScreenBrightness(brightness: Double, callback: (Result<Unit>) -> Unit)
  /** Gets the current battery info. */
  fun getBatteryInfo(callback: (Result<BatteryInfoMessage?>) -> Unit)
  /** Sets whether the video should loop. */
  fun setLooping(playerId: Long, looping: Boolean, callback: (Result<Unit>) -> Unit)
  /** Sets the video scaling mode. */
  fun setScalingMode(playerId: Long, mode: VideoScalingModeEnum, callback: (Result<Unit>) -> Unit)
  /** Sets the controls mode. */
  fun setControlsMode(playerId: Long, mode: ControlsModeEnum, callback: (Result<Unit>) -> Unit)
  /** Sets the active subtitle track. */
  fun setSubtitleTrack(playerId: Long, track: SubtitleTrackMessage?, callback: (Result<Unit>) -> Unit)
  /** Sets the subtitle render mode. */
  fun setSubtitleRenderMode(playerId: Long, mode: SubtitleRenderModeEnum, callback: (Result<Unit>) -> Unit)
  /** Adds an external subtitle file. */
  fun addExternalSubtitle(playerId: Long, source: SubtitleSourceMessage, callback: (Result<ExternalSubtitleTrackMessage?>) -> Unit)
  /** Removes an external subtitle track. */
  fun removeExternalSubtitle(playerId: Long, trackId: String, callback: (Result<Boolean>) -> Unit)
  /** Gets all external subtitle tracks. */
  fun getExternalSubtitles(playerId: Long, callback: (Result<List<ExternalSubtitleTrackMessage?>>) -> Unit)
  /** Sets the active audio track. */
  fun setAudioTrack(playerId: Long, track: AudioTrackMessage?, callback: (Result<Unit>) -> Unit)
  /** Enters picture-in-picture mode. */
  fun enterPip(playerId: Long, options: PipOptionsMessage, callback: (Result<Boolean>) -> Unit)
  /** Exits picture-in-picture mode. */
  fun exitPip(playerId: Long, callback: (Result<Unit>) -> Unit)
  /** Checks if PiP is supported on this platform. */
  fun isPipSupported(callback: (Result<Boolean>) -> Unit)
  /** Sets the actions available in PiP mode. */
  fun setPipActions(playerId: Long, actions: List<PipActionMessage?>, callback: (Result<Unit>) -> Unit)
  /** Enters fullscreen mode. */
  fun enterFullscreen(playerId: Long, callback: (Result<Boolean>) -> Unit)
  /** Exits fullscreen mode. */
  fun exitFullscreen(playerId: Long, callback: (Result<Unit>) -> Unit)
  /** Sets window fullscreen state (desktop platforms). */
  fun setWindowFullscreen(fullscreen: Boolean, callback: (Result<Unit>) -> Unit)
  /** Enables or disables background playback. */
  fun setBackgroundPlayback(playerId: Long, enabled: Boolean, callback: (Result<Boolean>) -> Unit)
  /** Checks if background playback is supported. */
  fun isBackgroundPlaybackSupported(callback: (Result<Boolean>) -> Unit)
  /** Gets available video quality tracks. */
  fun getVideoQualities(playerId: Long, callback: (Result<List<VideoQualityTrackMessage?>>) -> Unit)
  /** Sets the video quality track. */
  fun setVideoQuality(playerId: Long, track: VideoQualityTrackMessage, callback: (Result<Boolean>) -> Unit)
  /** Gets the current video quality track. */
  fun getCurrentVideoQuality(playerId: Long, callback: (Result<VideoQualityTrackMessage>) -> Unit)
  /** Checks if quality selection is supported. */
  fun isQualitySelectionSupported(playerId: Long, callback: (Result<Boolean>) -> Unit)
  /** Gets video metadata. */
  fun getVideoMetadata(playerId: Long, callback: (Result<VideoMetadataMessage?>) -> Unit)
  /** Sets media metadata for platform controls. */
  fun setMediaMetadata(playerId: Long, metadata: MediaMetadataMessage, callback: (Result<Unit>) -> Unit)
  /** Checks if casting is supported on this platform. */
  fun isCastingSupported(callback: (Result<Boolean>) -> Unit)
  /** Gets available cast devices. */
  fun getAvailableCastDevices(playerId: Long, callback: (Result<List<CastDeviceMessage?>>) -> Unit)
  /** Starts casting to a device. */
  fun startCasting(playerId: Long, device: CastDeviceMessage?, callback: (Result<Boolean>) -> Unit)
  /** Stops casting. */
  fun stopCasting(playerId: Long, callback: (Result<Boolean>) -> Unit)
  /** Gets the current cast state. */
  fun getCastState(playerId: Long, callback: (Result<CastStateEnum>) -> Unit)
  /** Gets the current cast device. */
  fun getCurrentCastDevice(playerId: Long, callback: (Result<CastDeviceMessage?>) -> Unit)

  companion object {
    /** The codec used by ProVideoPlayerHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonMessagesPigeonCodec()
    }
    /** Sets up an instance of `ProVideoPlayerHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: ProVideoPlayerHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.create$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceArg = args[0] as VideoSourceMessage
            val optionsArg = args[1] as VideoPlayerOptionsMessage
            api.create(sourceArg, optionsArg) { result: Result<Long> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.dispose$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.dispose(playerIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.play$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.play(playerIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.pause$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.pause(playerIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.stop$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.stop(playerIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.seekTo$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val positionMsArg = args[1] as Long
            api.seekTo(playerIdArg, positionMsArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setPlaybackSpeed$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val speedArg = args[1] as Double
            api.setPlaybackSpeed(playerIdArg, speedArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setVolume$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val volumeArg = args[1] as Double
            api.setVolume(playerIdArg, volumeArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getPosition$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.getPosition(playerIdArg) { result: Result<Long> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getDuration$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.getDuration(playerIdArg) { result: Result<Long> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getPlatformInfo$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getPlatformInfo{ result: Result<PlatformInfoMessage> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setVerboseLogging$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            api.setVerboseLogging(enabledArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsPictureInPicture$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsPictureInPicture{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsFullscreen$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsFullscreen{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsBackgroundPlayback$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsBackgroundPlayback{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsCasting$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsCasting{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsAirPlay$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsAirPlay{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsChromecast$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsChromecast{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsRemotePlayback$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsRemotePlayback{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsQualitySelection$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsQualitySelection{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsPlaybackSpeedControl$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsPlaybackSpeedControl{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsSubtitles$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsSubtitles{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsExternalSubtitles$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsExternalSubtitles{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsAudioTrackSelection$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsAudioTrackSelection{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsChapters$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsChapters{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsVideoMetadataExtraction$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsVideoMetadataExtraction{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsNetworkMonitoring$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsNetworkMonitoring{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsBandwidthEstimation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsBandwidthEstimation{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsAdaptiveBitrate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsAdaptiveBitrate{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsHLS$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsHLS{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsDASH$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsDASH{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsDeviceVolumeControl$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsDeviceVolumeControl{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.supportsScreenBrightnessControl$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.supportsScreenBrightnessControl{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getDeviceVolume$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getDeviceVolume{ result: Result<Double> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setDeviceVolume$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val volumeArg = args[0] as Double
            api.setDeviceVolume(volumeArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getScreenBrightness$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getScreenBrightness{ result: Result<Double> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setScreenBrightness$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val brightnessArg = args[0] as Double
            api.setScreenBrightness(brightnessArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getBatteryInfo$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getBatteryInfo{ result: Result<BatteryInfoMessage?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setLooping$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val loopingArg = args[1] as Boolean
            api.setLooping(playerIdArg, loopingArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setScalingMode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val modeArg = args[1] as VideoScalingModeEnum
            api.setScalingMode(playerIdArg, modeArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setControlsMode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val modeArg = args[1] as ControlsModeEnum
            api.setControlsMode(playerIdArg, modeArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setSubtitleTrack$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val trackArg = args[1] as SubtitleTrackMessage?
            api.setSubtitleTrack(playerIdArg, trackArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setSubtitleRenderMode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val modeArg = args[1] as SubtitleRenderModeEnum
            api.setSubtitleRenderMode(playerIdArg, modeArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.addExternalSubtitle$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val sourceArg = args[1] as SubtitleSourceMessage
            api.addExternalSubtitle(playerIdArg, sourceArg) { result: Result<ExternalSubtitleTrackMessage?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.removeExternalSubtitle$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val trackIdArg = args[1] as String
            api.removeExternalSubtitle(playerIdArg, trackIdArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getExternalSubtitles$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.getExternalSubtitles(playerIdArg) { result: Result<List<ExternalSubtitleTrackMessage?>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setAudioTrack$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val trackArg = args[1] as AudioTrackMessage?
            api.setAudioTrack(playerIdArg, trackArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.enterPip$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val optionsArg = args[1] as PipOptionsMessage
            api.enterPip(playerIdArg, optionsArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.exitPip$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.exitPip(playerIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.isPipSupported$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.isPipSupported{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setPipActions$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val actionsArg = args[1] as List<PipActionMessage?>
            api.setPipActions(playerIdArg, actionsArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.enterFullscreen$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.enterFullscreen(playerIdArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.exitFullscreen$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.exitFullscreen(playerIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setWindowFullscreen$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val fullscreenArg = args[0] as Boolean
            api.setWindowFullscreen(fullscreenArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setBackgroundPlayback$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val enabledArg = args[1] as Boolean
            api.setBackgroundPlayback(playerIdArg, enabledArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.isBackgroundPlaybackSupported$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.isBackgroundPlaybackSupported{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getVideoQualities$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.getVideoQualities(playerIdArg) { result: Result<List<VideoQualityTrackMessage?>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setVideoQuality$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val trackArg = args[1] as VideoQualityTrackMessage
            api.setVideoQuality(playerIdArg, trackArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getCurrentVideoQuality$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.getCurrentVideoQuality(playerIdArg) { result: Result<VideoQualityTrackMessage> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.isQualitySelectionSupported$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.isQualitySelectionSupported(playerIdArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getVideoMetadata$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.getVideoMetadata(playerIdArg) { result: Result<VideoMetadataMessage?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.setMediaMetadata$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val metadataArg = args[1] as MediaMetadataMessage
            api.setMediaMetadata(playerIdArg, metadataArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.isCastingSupported$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.isCastingSupported{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getAvailableCastDevices$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.getAvailableCastDevices(playerIdArg) { result: Result<List<CastDeviceMessage?>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.startCasting$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            val deviceArg = args[1] as CastDeviceMessage?
            api.startCasting(playerIdArg, deviceArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.stopCasting$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.stopCasting(playerIdArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getCastState$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.getCastState(playerIdArg) { result: Result<CastStateEnum> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerHostApi.getCurrentCastDevice$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val playerIdArg = args[0] as Long
            api.getCurrentCastDevice(playerIdArg) { result: Result<CastDeviceMessage?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Flutter API for callbacks from the platform to Dart.
 *
 * This API is implemented in Dart and called from the native platform
 * to send events.
 *
 * Generated class from Pigeon that represents Flutter messages that can be called from Kotlin.
 */
class ProVideoPlayerFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by ProVideoPlayerFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonMessagesPigeonCodec()
    }
  }
  /** Called when a video player event occurs. */
  fun onEvent(playerIdArg: Long, eventArg: VideoPlayerEventMessage, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.pro_video_player_platform_interface.ProVideoPlayerFlutterApi.onEvent$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(playerIdArg, eventArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
